1. Архитектура программного обеспечения включает в себя
A) Только UI
B) Только бизнес-логику
C) Структуру и поведение системы
D) Только базу данных
E) Только документацию из системы
ANSWER: C) Структуру и поведение системы

2. Паттерн архитектуры, разделяющий модель, представление и контроллер
A) MVVM
B) MVC
C) MVP
D) Clean
E) Hexagonal
ANSWER: B) MVC

3. Принцип Single Responsibility из SOLID обозначает
A) Метод должен быть только публичным
B) Каждый класс отвечает за одну задачу
C) Все классы должны быть универсальными
D) Интерфейсы не должны зависеть друг от друга
E) Модули нужно объединять
ANSWER: B) Каждый класс отвечает за одну задачу

4. Микросервисная архитектура
A) Архитектура на основе одного монолита
B) Отказ от архитектурных паттернов
C) Разделение приложения на независимые сервисы
D) Использование одной базы данных
E) Разработка без документации архитектурных паттернов
ANSWER: C) Разделение приложения на независимые сервисы

5. Принцип из SOLID, рекомендующий зависеть от абстракций, а не от конкретных реализаций
A) O
B) S
C) L
D) D
E) I
ANSWER: D) D

6. Архитектурный паттерн особенно популярен в мобильной разработке на iOS
A) MVP
B) MVVM
C) MVC
D) Layered
E) Monolithic
ANSWER: B) MVVM

7. RESTful API - это
A) API на базе SOAP
B) API, использующее JSON-RPC
C) API, основанное на архитектурных принципах REST
D) Локальное хранилище данных
E) API, использующее только GET-запросы
ANSWER: C) API, основанное на архитектурных принципах REST

8. Является преимуществом микросервисной архитектуры
A) Централизованная база данных
B) Простота отладки
C) Легкость масштабирования
D) Зависимость всех компонентов
E) Меньше кода
ANSWER: C) Легкость масштабирования

9. Компонент, который обычно отвечает за отображение данных пользователю
A) Контроллер
B) Онлайн-сервис
C) Модель
D) Представление
E) База данных
ANSWER: D) Представление

10. Принцип Open/Closed из SOLID означает
A) Открыт для модификации
B) Закрыт для использования
C) Открыт для расширения
D) Закрыт для наследования
E) Открыт для любого кода
ANSWER: C) Открыт для расширения

11. Формат, часто использующийся для описания архитектуры в виде диаграммы
A) CSV
B) UML
C) TXT
D) DOC
E) HTML
ANSWER: B) UML

12. Слой в многослойной архитектуре обрабатывающий бизнес-логику
A) UI
B) Presentation
C) Domain
D) Data
E) Service
ANSWER: C) Domain

13. Контейнеризация в архитектуре представляет собой
A) Работу только на сервере
B) Использование Docker или Kubernetes
C) Сборку проекта
D) Описание бизнес-процессов
E) Разделение данных на группы кластеризация данных
ANSWER: B) Использование Docker или Kubernetes

14. Масштабировать систему горизонтально позволяет
A) Увеличение оперативной памяти
B) Добавление новых серверов
C) Использование кэша
D) Переписывание кода
E) Удаление старых функций
ANSWER: B) Добавление новых серверов

15. Определить производительность архитектурного решения помогает
A) Код-ревью
B) База данных
C) Нагрузочное тестирование
D) Пользовательский интерфейс
E) Дизайн
ANSWER: C) Нагрузочное тестирование

16. Паттерн для разделения UI и бизнес-логики
A) Singleton
B) Observer
C) MVVM
D) Factory
E) Adapter
ANSWER: C) MVVM

17. Кэширование - это
A) Конфиденциальных и временное удаление данных
B) Сжатие кода
C) Временное хранение часто используемых данных
D) Удаление ошибок
E) Перезапуск приложения
ANSWER: C) Временное хранение часто используемых данных

18. SOLID - это
A) Метод сжатия данных
B) Принципы проектирования архитектуры
C) Язык программирования
D) Пользовательский тип интерфейса
E) Тип модели
ANSWER: B) Принципы проектирования архитектуры

19. Подход, помогающий сделать архитектуру более гибкой
A) Жесткое связывание
B) Большие классы
C) Использование абстракций
D) Монолитное приложение
E) Скрытые зависимости
ANSWER: C) Использование абстракций

20. Формат чаще всего использующийся для REST API
A) XML
B) CSV
C) JSON
D) DOCX
E) PDF
ANSWER: C) JSON

21. Архитектурный шаблон - это
A) Поддержка и развитие кодовой базы
B) Готовая программа
C) Повторяемое архитектурное решение
D) Локальное хранилище
E) Устройство сервера
ANSWER: C) Повторяемое архитектурное решение

22. DRY означает
A) Делай редко
B) Don't Repeat Yourself
C) Дублируй рефакторинг
D) Debug Remote YAML
E) Data Request Yield
ANSWER: B) Don't Repeat Yourself

23. Для документирования архитектуры лучше использовать
A) Paint
B) Notepad
C) UML
D) PDF
E) DOCX
ANSWER: C) UML

24. Увеличивает отказоустойчивость системы
A) Один сервер
B) Централизованный лог
C) Резервное копирование и кластеризация
D) Монолитный код
E) Большое количество функций и высокая функциональность
ANSWER: C) Резервное копирование и кластеризация

25. Подход для проектирования RESTful API
A) SOAP
B) RPC
C) HTTP и ресурсы
D) TCP
E) FTP и ресурсы
ANSWER: C) HTTP и ресурсы

26. Принцип для выявления слабых мест архитектуры
A) Обфускация
B) Unit-тестирование
C) Архитектурное ревью
D) UI-дизайн
E) Рефакторинг кода
ANSWER: C) Архитектурное ревью

27. Для многопользовательских приложений лучше использовать
A) Локальное хранение
B) Интегрированную архитектуру
C) Шинную архитектуру
D) Клиент-серверную архитектуру
E) Один поток
ANSWER: D) Клиент-серверную архитектуру

28. В обязанности архитектора ПО входит
A) Написание и редактирование HTML
B) Разработка драйверов
C) Проектирование архитектуры системы
D) Администрирование серверов
E) Дизайн логотипа
ANSWER: C) Проектирование архитектуры системы

29. Паттерн проектирования, обеспечивающий инкапсуляцию создания объектов
A) Singleton
B) Factory
C) Adapter
D) Bridge
E) Proxy
ANSWER: B) Factory

30. Помогает выявить риски архитектурного решения
A) Использование одного сервера
B) Нагрузочное тестирование и анализ
C) Исключение бизнес-логики
D) Комментарии и описания в начале коде
E) Упрощённый UI
ANSWER: B) Нагрузочное тестирование и анализ

31. Архитектурный подход повышает модульность и переиспользуемость кода
A) Монолитная архитектура
B) Событийно-ориентированная архитектура
C) Микросервисная архитектура
D) MVC без слоёв
E) Архитектура с жёсткими связями
ANSWER: C) Микросервисная архитектура

32. Преимущество клиент-серверной архитектуры
A) Централизованное управление
B) Отсутствие кэша
C) Использование одного компонента
D) Локальное хранение
E) Нет необходимости в API
ANSWER: A) Централизованное управление

33. Паттерн проектирования облегчает реализацию интерфейса с помощью разных представлений
A) Decorator
B) Strategy
C) MVVM
D) Factory
E) Observer
ANSWER: A) Decorator

34. Следует учитывать при выборе архитектуры
A) Только язык программирования
B) Мнение дизайнера
C) Бизнес-требования и цели проекта
D) Цвет интерфейса
E) Версию браузера
ANSWER: C) Бизнес-требования и цели проекта

35. Архитектурные диаграммы применяются
A) Для декорирования стилизация проекта
B) Для описания кода
C) Для визуализации структуры системы
D) Для создания логотипа
E) Для генерации документации
ANSWER: C) Для визуализации структуры системы

36. Позволяет масштабировать микросервисную систему
A) Увеличение числа компонентов
B) Централизованная база данных
C) Разделение на слои
D) Скрытие логики
E) Удаление интерфейса
ANSWER: A) Увеличение числа компонентов

37. Архитектурный стиль ориентирован на асинхронную обработку событий
A) REST
B) SOAP
C) Event-driven
D) MVC
E) Singleton
ANSWER: C) Event-driven

38. Входит в документацию архитектуры
A) Список сотрудников
B) Финансовый отчёт
C) Диаграммы компонентов
D) Только тест-кейсы
E) Маркетинговая стратегия
ANSWER: C) Диаграммы компонентов

39. Уязвимость архитектуры
A) Высокая модульность
B) Отказоустойчивость системы
C) Слабая изоляция компонентов
D) Использование SOLID
E) Наличие логов
ANSWER: C) Слабая изоляция компонентов

40. Включает в себя SOLID
A) Принципы оптимизации запросы SQL
B) Принципы рефакторинга
C) Принципы надёжной архитектуры ООП
D) Способы создания веб-сайтов
E) Стандарты документации
ANSWER: C) Принципы надёжной архитектуры ООП

41. Шаблоны проектирования используют
A) Для копирования чужого кода
B) Для ускорения рендеринга
C) Для решения типовых архитектурных задач
D) Для генерации HTML и динамический контент
E) Для написания инструкций
ANSWER: C) Для решения типовых архитектурных задач

42. Позволяет повысить отказоустойчивость архитектуры
A) Использование одного сервера
B) Отсутствие кэширования
C) Наличие бэкапов и кластеризации
D) Централизация логики
E) Удаление Учитывать при выборе архитектуры
ANSWER: C) Наличие бэкапов и кластеризации

43. Преобразование строки в целое число в Python выполняется функцией
A. int('123')
B. str(123)
C. num('123')
D. parse('123')
E. to_int('123')
ANSWER: A. int('123')

44. Объединение строк в Python осуществляется через оператор
A. 'a' + 'b'
B. concat('a','b')
C. join('a','b')
D. merge('a','b')
E. add('a','b')
ANSWER: A. 'a' + 'b'

45. Получение длины строки в Python выполняется функцией
A. len(s)
B. s.length()
C. size(s)
D. s.len()
E. str.len(s)
ANSWER: A. len(s)

46. Перехват всех исключений в Python выполняется конструкцией
A. except Exception:
B. catch all:
C. except *:
D. except Any:
E. except All:
ANSWER: A. except Exception:

47. Импорт модуля math в Python выполняется командой
A. import math
B. load math
C. require math
D. include math
E. using math
ANSWER: A. import math

48. Открытие файла для чтения в Python выполняется функцией
A. open('file','r')
B. file.open('r')
C. read.open('file')
D. open.read('file')
E. io.open('file')
ANSWER: A. open('file','r')

49. Объявление класса в Python выполняется ключевым словом
A. class Имя:pass
B. def Class():pass
C. struct Имя:pass
D. module Имя:pass
E. type Имя:pass
ANSWER: A. class Имя:pass

50. Паттерн чаще всего используют для управления зависимостями
A) Builder
B) Factory
C) Dependency Injection
D) Observer
E) Proxy
ANSWER: C) Dependency Injection

51. Помогает в архитектуре при интеграции внешних сервисов
A) Наличие только одного API и узкое место
B) Отсутствие документации
C) Использование абстрактного слоя
D) Полная централизация
E) Скрытые зависимости
ANSWER: C) Использование абстрактного слоя

52. Архитектура REST -
A) Архитектура пользовательских интерфейсов
B) Стиль архитектуры веб-сервисов
C) Модель базы данных
D) Сеть TCP/IP
E) Язык программирования
ANSWER: B) Стиль архитектуры веб-сервисов

53. Контейнеризация -
A) Метод уплотнения кода и удаление пробелов
B) Способ хранения данных в базе
C) Изоляция сервисов в независимые среды
D) Метод хранения логов
E) Способ упаковки HTML
ANSWER: C) Изоляция сервисов в независимые среды

54. Архитектура используемая в облачных приложениях
A) Только монолит
B) Двухуровневая
C) Микросервисная
D) Локальная
E) Объектно-ориентированная
ANSWER: C) Микросервисная

55. Термин "технический долг" -
A) Сумма оплаты архитектору и финансовое возмещение
B) Количество багов
C) Недоработки, оставленные в коде для ускорения разработки
D) Количество строк кода
E) Долг по тестированию
ANSWER: C) Недоработки, оставленные в коде для ускорения разработки

56. Применяется в архитектуре для обеспечения безопасности
A) Игнорирование API
B) Использование открытого доступа
C) Аутентификация и шифрование
D) Удаление журналов
E) Упрощение структуры
ANSWER: C) Аутентификация и шифрование

57. Необходимо учитывать при проектировании для IoT
A) Только UI
B) Ограниченные ресурсы устройств
C) Мультиязычность
D) Цвет и стиль
E) Большой экран высокого разрешения
ANSWER: B) Ограниченные ресурсы устройств

58. Принцип KISS
A) Keep It Safe & Secure
B) Keep It Short & Simple
C) Keep Interface Static & Stable
D) Key In Secure Systems
E) Kernel Interface Service Setup
ANSWER: B) Keep It Short & Simple

59. Делает архитектуру более гибкой
A) Использование глобальных переменных
B) Жесткие связи
C) Использование интерфейсов и абстракций
D) Централизация всех компонентов
E) Множественные зависимости
ANSWER: C) Использование интерфейсов и абстракций

60. Паттерн используемый для представления операций как объектов
A) Builder
B) Strategy
C) Command
D) Factory
E) Observer
ANSWER: C) Command

61. Архитектура включает с высокой доступностью
A) Использование одного сервера без распределения нагрузки
B) Минимум резервов
C) Горизонтальное масштабирование и отказоустойчивость
D) Отказ от логирования
E) Только один поток
ANSWER: C) Горизонтальное масштабирование и отказоустойчивость

62. Минимизирует технический долг
A) Игнорирование ошибок
B) Документирование и рефакторинг
C) Исключение тестирования как части процесса контроля качества
D) Централизация
E) Отказ от обновлений
ANSWER: B) Документирование и рефакторинг

63. Улучшает пользовательский опыт
A) Медленная загрузка
B) Продуманный UI и архитектура
C) Отсутствие документации
D) Сложные переходы
E) Неоптимизированные данные
ANSWER: B) Продуманный UI и архитектура

64. Преобразование строки в целое число в Python выполняется функцией
A. int('123')
B. str(123)
C. num('123')
D. parse('123')
E. to_int('123')
ANSWER: A. int('123')

65. Архитектура на основе событий позволяет
A) Оптимизировать и упростить архитектурную логику
B) Увеличить связность
C) Отделить обработку событий от источников
D) Избежать кода
E) Заменить базу данных
ANSWER: C) Отделить обработку событий от источников

66. Улучшает масштабируемость системы
A) Применение архитектуры с одним сервером
B) Статическая архитектура
C) Разделение на независимые модули
D) Объединение всех компонентов
E) Полный отказ от API
ANSWER: C) Разделение на независимые модули

67. Паттерн Proxy
A) Создание интерфейсов
B) Представление объекта с контролем доступа
C) Подробное текстовое описание структуры
D) Работа с массивами
E) Управление памятью
ANSWER: B) Представление объекта с контролем доступа

68. Термин "архитектурный паттерн"
A) Случайное решение
B) Некорректно выбранный метод решения задачи
C) Повторяемое решение архитектурной задачи
D) Библиотека функций
E) Рефакторинг кода
ANSWER: C) Повторяемое решение архитектурной задачи

69. Предоставляет взаимодействие между разными архитектурными компонентами
A) Сжатие данных
B) Шифрование
C) API-интерфейсы
D) Хеширование
E) Тестирование
ANSWER: C) API-интерфейсы

70. Включает клиент-серверная архитектура
A) Только один сервер
B) Набор HTML-страниц
C) Разделение на клиентскую и серверную части
D) Только backend
E) Используется исключительно frontend-часть приложения
ANSWER: C) Разделение на клиентскую и серверную части

71. Определяет, масштобируемость архитектуры
A) Количество тестов
B) Уровень абстракции
C) Способность обрабатывать растущую нагрузку
D) Язык программирования, применяемый для написания кода
E) Скорость компиляции
ANSWER: C) Способность обрабатывать растущую нагрузку

72. Исключение элементов при генерации списка в Python выполняется через выражение
A. [x for x in lst if cond]
B. (x for x in lst)
C. filter(lambda x: cond, lst)
D. map(lambda x: cond, lst)
E. itertools.compress(lst)
ANSWER: A. [x for x in lst if cond]

73. Принцип предполагающий разделение обязанностей между слоями
A) YAGNI
B) DRY
C) SOLID
D) WET
E) OOP
ANSWER: C) SOLID

74. принцип DRY обозначает
A) Делай Рефакторинг Явно
B) Don't Repeat Yourself
C) Debug Rapid Yield
D) Data Rewrite Yearly
E) Direct Render YAML
ANSWER: B) Don't Repeat Yourself

75. Делает систему более поддерживаемой
A) Монолит
B) Жесткая связность
C) Модульность
D) Единый класс
E) Глобальные переменные
ANSWER: C) Модульность

76. Является недостатком монолитной архитектуры
A) Простота кода
B) Высокая скорость разработки
C) Трудности масштабирования
D) Лёгкость деплоя
E) Отсутствие зависимостей
ANSWER: C) Трудности масштабирования

77. Термин "микрофронтенд"
A) Веб-страница, содержащая только основную и необходимую информацию
B) Локальный интерфейс
C) Архитектурный подход к разбиению фронтенда на независимые модули
D) CSS-оптимизация
E) Набор JavaScript-файлов
ANSWER: C) Архитектурный подход к разбиению фронтенда на независимые модули

78. Следует учитывать при интеграции с внешними API
A) Цвет интерфейса
B) Частоту обновлений сайта
C) Формат, безопасность и обработку ошибок
D) Стили CSS
E) Структуру базы данных
ANSWER: C) Формат, безопасность и обработку ошибок

79. Делает архитектуру гибкой и расширяемой
A) Жесткая логика
B) Централизация
C) Использование абстракций и интерфейсов
D) Моноархитектура
E) Обширное количество файлов, затрудняющее навигацию
ANSWER: C) Использование абстракций и интерфейсов

80. Помогает масштабировать архитектуру
A) Удаление кэша
B) Использование одного сервера
C) Горизонтальное масштабирование
D) Один API
E) Тесты
ANSWER: C) Горизонтальное масштабирование

81. Помогает визуализировать архитектуру
A) MS Paint
B) Visual Studio Code
C) UML-диаграммы
D) Архиватор
E) Git
ANSWER: C) UML-диаграммы

82. Разделяет архитектуру по слоям
A) Простая структура
B) Функциональные зависимости
C) Многоуровневая архитектура
D) Наличие UI
E) Наличие логов
ANSWER: C) Многоуровневая архитектура

83. RESTful API -
A) Программа для обработки ошибок
B) Метод хранения данных
C) Архитектурный стиль
D) Сервер базы данных
E) Фреймворк
ANSWER: C) Архитектурный стиль

84. Подход к архитектуре учитывает высокую доступность и отказоустойчивость
A) Модульная разработка
B) Frontend-ориентированная архитектура
C) Распределённая архитектура
D) Локальная система
E) Моноархитектура
ANSWER: C) Распределённая архитектура

85. Улучшает безопасность архитектуры
A) Прозрачные данные
B) Отсутствие логирования
C) Шифрование и аутентификация
D) Использование глобальных переменных
E) Независимые модули
ANSWER: C) Шифрование и аутентификация

86. Принцип SRP из SOLID
A) Сокращение ресурсов приложения
B) Single Responsibility Principle
C) Simple Reuse Pattern
D) Secure Runtime Processing
E) Storage Reduction Principle
ANSWER: B) Single Responsibility Principle

87. Относится к методу документирования архитектуры
A) Комментарии в коде
B) Структурированный JSON-файл
C) Диаграмма компонентов
D) README файл
E) Таблица значений
ANSWER: C) Диаграмма компонентов

88. Обозначает принцип OCP в SOLID
A) Only Code Processing
B) Open Closed Principle
C) One Code Part
D) Object Creation Process
E) Option Control Program
ANSWER: B) Open Closed Principle

89. Архитектурный стиль лучше всего подходит для распределенных систем
A) MVC
B) MVVM
C) P2P
D) Микросервисы
E) Монолит
ANSWER: D) Микросервисы

90. Делает систему отказоустойчивой
A) Использование один сервер
B) Отсутствие логирования
C) Резервирование компонентов
D) Слабая связность
E) Простой интерфейс
ANSWER: C) Резервирование компонентов

91. Обозначает понятие "технический долг"
A) Отсутствие документации
B) Невыполненные задачи в спринте
C) Компромиссы в коде, снижающие его качество
D) Логические ошибки и баги, вызывающие сбои в работе системы
E) Пропущенные юнит-тесты
ANSWER: C) Компромиссы в коде, снижающие его качество

92. Кэширование в архитектуре
A) Замедление системы
B) Удаление данных
C) Быстрый доступ
D) Повторный ввод
E) Ошибки компиляции
ANSWER: C) Быстрый доступ

93. Метод применяемый для документирования архитектуры
A) UML
B) SMTP
C) TCP
D) JSON
E) FTP
ANSWER: A) UML

94. Позволяет минимизировать дублирование кода
A) Прямое копирование
B) Переименование переменных
C) Вынос общей логики модули
D) Увеличение числа классов
E) Удаление комментариев
ANSWER: C) Вынос общей логики модули

95. Оценивает производительность архитектуры
A) Внешний вид интерфейса
B) Размер проекта
C) Нагрузочное тестирование
D) Количество разработчиков
E) Статический анализ
ANSWER: C) Нагрузочное тестирование

96. Реализовывает горизонтальное масштабирование
A) Увеличение оперативной памяти
B) Добавление новых серверов
C) Установка браузера
D) Перезапуск приложения
E) Удаление логов
ANSWER: B) Добавление новых серверов

97. Является паттерном проектирования
A) GitHub
B) Singleton
C) CSS
D) TCP
E) Docker
ANSWER: B) Singleton

98. SOLID отвечает за ослабление связности компонентов
A) DIP
B) LSP
C) SRP
D) ISP
E) DRY
ANSWER: A) DIP

99. Получение размера списка в Python выполняется функцией
A. len(list) вызывается
B. list.length вызывается
C. list.size() вызывается
D. list.count() вызывается
E. list.count(elem) вызывается
ANSWER: A. len(list) вызывается

100. Включает архитектура REST
A) Сессии
B) Текущее состояние данных и процессов, хранящихся на сервере
C) Использование стандартных HTTP методов
D) Физические подключения
E) Флеш-технологии
ANSWER: C) Использование стандартных HTTP методов

101. Включает документация по архитектуре
A) Использование цветового оформления важных элементов
B) Логотип
C) Диаграммы, описания компонентов, протоколы
D) Копии писем
E) Скриншоты интерфейса
ANSWER: C) Диаграммы, описания компонентов, протоколы

102. Необходимо для мониторинга архитектуры
A) Графический интерфейс
B) Статические файлы
C) Метрики, логирование, алерты
D) Количество разработчиков
E) Количество таблиц в БД
ANSWER: C) Метрики, логирование, алерты

103. Элемент архитектуры может быть реализован как RESTful-сервис
A) Конструктор
B) Кнопка
C) Контроллер
D) API
E) Цикл
ANSWER: D) API

104. Event-Driven архитектура -
A) Архитектура на основе фреймворков
B) Веб-дизайн
C) Архитектура, реагирующая на события
D) Приложение для десктопа и для планшета
E) UI шаблон
ANSWER: C) Архитектура, реагирующая на события

105. "Масштабирование по вертикали" -
A) Увеличение количества пользователей
B) Добавление новых модулей
C) Увеличение мощности одного сервера
D) Добавление экранов
E) Объединение функций
ANSWER: C) Увеличение мощности одного сервера

106. Используется для управления версиями архитектуры
A) Архитектурная диаграмма
B) Схемы интерфейса
C) Система контроля версий
D) Документ Word
E) Таблица Excel
ANSWER: C) Система контроля версий

107. Принцип LSP
A) Least Secure Process Path
B) List Source Pattern
C) Liskov Substitution Principle
D) Logical Server Path
E) Large Stack Partition
ANSWER: C) Liskov Substitution Principle

108. Шаблон архитектуры используется для визуального разделения слоев
A) Singleton
B) Observer
C) MVC
D) Adapter
E) Factory
ANSWER: C) MVC

109. Подход к архитектуре помогает лучше масштабировать интерфейсы
A) Минимизация CSS
B) Разделение UI на микрофронтенды
C) Единый HTML
D) Использование одного файла
E) Встроенные стили
ANSWER: B) Разделение UI на микрофронтенды

110. Определяет архитектура программного обеспечения
A) Тема сайта
B) Интерфейс пользователя
C) Структуру, компоненты и их взаимодействие
D) Количество строк кода
E) Операционную систему с поддержкой необходимых драйверов и обновлений
ANSWER: C) Структуру, компоненты и их взаимодействие

111. Термин "отказоустойчивость" -
A) Повышенная нагрузка
B) Работа без тестов
C) Способность системы продолжать работу при сбоях
D) Принудительное завершение работы
E) Резервное копирование
ANSWER: C) Способность системы продолжать работу при сбоях

112. Принцип ISP в SOLID
A) Internal Secure Processing
B) Interface Segregation Principle
C) Input Source Pointer
D) Information Separation Protocol
E) Independent Stack Procedure
ANSWER: B) Interface Segregation Principle

113. Управление конфигурацией архитектуры
A) Excel-файл с таблицами и формулами для анализа информации
B) Схема БД
C) CI/CD инструменты и YAML-файлы
D) Документ Word с форматированием и вставкой изображений
E) Панель управления
ANSWER: C) CI/CD инструменты и YAML-файлы

114. Определяет бизнес-требования к архитектуре
A) Схема БД
B) Кодовая база
C) Анализ требований и интервью с заказчиком
D) Тесты
E) Цветовая схема, определяющая гармоничное сочетание цветов
ANSWER: C) Анализ требований и интервью с заказчиком

115. Контролирует качество архитектуры
A) Визуальный дизайн
B) А/В тестирование
C) Архитектурный аудит
D) Установка CMS
E) Перезапуск сервера
ANSWER: C) Архитектурный аудит

116. Термин "архитектура с высокой доступностью" -
A) Интерфейс всегда доступен
B) Меньше кода
C) Система доступна для пользователей в любое время
D) Низкое разрешение
E) Маленький размер БД что обеспечивает быструю обработку
ANSWER: C) Система доступна для пользователей в любое время

117. Необходим для построения надежной архитектуры
A) Использование одних и тех же компонентов
B) Быстрая разработка
C) Учёт безопасности, отказоустойчивости
D) Копирование чужих решений
E) Монофункциональный подход
ANSWER: C) Учёт безопасности, отказоустойчивости

118. Принцип SOLID предотвращает создание "бога-объекта"
A) SRP
B) OCP
C) LSP
D) ISP
E) DIP
ANSWER: A) SRP

119. Термин "архитектурный паттерн" -
A) Графика сайта для функциональности
B) Повторяемое архитектурное решение
C) Имя переменной
D) Схема данных
E) Страница документации
ANSWER: B) Повторяемое архитектурное решение

120. Масштабируемость системы
A) Возможность легко изменять размер шрифта
B) Простота доступа
C) Способность адаптироваться к увеличению нагрузки
D) Удаление ошибок
E) Минимизация кода
ANSWER: C) Способность адаптироваться к увеличению нагрузки

121. Включает архитектура MVC
A) Main -- Visual -- Controller
B) Memory -- Volume -- Cache
C) Model -- View -- Controller
D) Move -- View -- Create
E) Model -- Version -- CSS
ANSWER: C) Model -- View -- Controller

122. учитывают при проектировании архитектуры для IoT
A) Большой экран
B) Быстрая анимация
C) Ограниченные ресурсы устройств
D) Отсутствие сети подключения
E) Высокое энергопотребление
ANSWER: C) Ограниченные ресурсы устройств

123. REST в контексте API
A) Random Endpoint Service Transfer
B) Reliable Embedded Secure Transfer
C) Representational State Transfer
D) Real System Transport
E) Request System Tool
ANSWER: C) Representational State Transfer

124. Принцип архитектуры, связанный с раздельной ответственностью компонентов
A) Монолитность
B) Разделение стилей
C) Разделение обязанностей
D) Интерфейсная логика
E) Глобальные переменные
ANSWER: C) Разделение обязанностей

125. Тип архитектуры, позволяющий легче внедрять CI/CD
A) Одноблочная
B) Монолит
C) Микросервисная
D) Локальная
E) Интегральная
ANSWER: C) Микросервисная

126. Обозначает MVVM
A) Module--View--VisualMethod
B) Model--View--ViewModel
C) Memory--Version--Variable Model
D) Markup--View--Middleware
E) Media--Visual--Version Map
ANSWER: B) Model--View--ViewModel

127. Контейнеризация в архитектуре программного обеспечения
A) Деление БД
B) Упаковка приложения с зависимостями
C) Архивирование и хранение логов
D) Удаление кода
E) Интеграция с API
ANSWER: B) Упаковка приложения с зависимостями

128. Механизмы контроля технического долга в архитектуре
A) Быстрая сборка
B) Полный рефакторинг без плана
C) Код-ревью и метрики качества
D) Обход тестов
E) Скрытие ошибок
ANSWER: C) Код-ревью и метрики качества

129. Необходимые элементы при проектировании многослойной архитектуры
A) Все компоненты в одном файле
B) Разделение на уровни (презентация, логика,)
C) Использование одной переменной эффективно
D) Прямое подключение к БД
E) Использование FTP
ANSWER: B) Разделение на уровни (презентация, логика,)

130. Стратегии управления жизненным циклом компонентов
A) Удаление всех данных
B) Обновление интерфейса
C) Разработка, обновление
D) Выбор цвета
E) Добавление логотипа
ANSWER: C) Разработка, обновление

131. Понятие архитектуры с учётом интернационализации
A) Поддержка нескольких языков и культурных форматов
B) Одна кодировка
C) Работа только в одном регионе
D) Моноязычный интерфейс
E) Вывод чисел без точек
ANSWER: A) Поддержка нескольких языков и культурных форматов

132. Механизмы обеспечения безопасности архитектуры
A) Статические изображения и фиксированные файлы
B) Низкий FPS
C) Контроль доступа, шифрование и резервные копии
D) Быстрое тестирование
E) Удаление CSS
ANSWER: C) Контроль доступа, шифрование и резервные копии

133. Архитектурной стратегии для мобильных приложений
A) Flash-анимации
B) Маленькие шрифты и компактный тексты для системы
C) Оптимизация производительности и потребления ресурсов
D) Только iOS
E) Локальные переменные
ANSWER: C) Оптимизация производительности и потребления ресурсов

134. Необходимые условия для поддержки микрофронтендов
A) Единый CSS-файл
B) Использование iframe
C) Изоляция и независимость
D) Отказ от шаблонов
E) Прямая интеграция в HTML
ANSWER: C) Изоляция и независимость

135. Понятие тестирования на уровне архитектуры
A) Отладка HTML
B) Проверка визуального дизайна
C) Анализ производительности
D) Подсчет строк кода
E) Удаление лишних файлов
ANSWER: C) Анализ производительности

136. Основные аспекты, учитываемые при проектировании RESTful API
A) Платформу Android
B) Использование POST только
C) Ресурсо-ориентированный подход и стандарты HTTP
D) Подключение к Wi-Fi
E) Использование XML
ANSWER: C) Ресурсо-ориентированный подход и стандарты HTTP

137. Понятие архитектуры, основанной на событиях
A) Статическая архитектура
B) Жесткая иерархия
C) Реакция компонентов на события в системе
D) Визуальное проектирование
E) Непрерывный интерфейс
ANSWER: C) Реакция компонентов на события в системе

138. Архитектура SOAP-сервисов
A) REST-методы
B) HTML-страницы
C) XML-сообщения
D) CSS-стили
E) SQL-запросы
ANSWER: C) XML-сообщения

139. Факторы, определяющие целостность данных в архитектуре
A) Количество кода
B) Структура папок
C) Надежность хранения и передачи без искажений
D) Цветовая схема
E) Количество окон
ANSWER: C) Надежность хранения и передачи без искажений

140. Способы внедрения мониторинга в архитектуру
A) Удаление логов
B) Отказ от анализа
C) Использование Prometheus, Grafana и логирования
D) Установка драйвера
E) Удаление всех переменных
ANSWER: C) Использование Prometheus, Grafana и логирования

141. Факторы, позволяющие адаптировать архитектуру под разные устройства
A) Устройство с высоким разрешением экрана
B) Масштабируемый интерфейс и адаптивный дизайн
C) Полный отказ от адаптивной настройки
D) Использование одной многофункциональной кнопки
E) Закрытие панели основной навигации
ANSWER: B) Масштабируемый интерфейс и адаптивный дизайн

142. Важные аспекты, учитываемые при работе с кэшированием
A) Отсутствие синхронизации
B) Повторный ввод
C) Актуальность и время жизни данных
D) Принудительное удаление всех сохранённых данных
E) Постоянное обновление
ANSWER: C) Актуальность и время жизни данных

143. Паттерн архитектуры, помогающий в построении гибкой системы
A) Procedural
B) Singleton
C) Layered
D) Rigid
E) Static
ANSWER: C) Layered

144. Архитектурная диаграмма
A) Код классов
B) SQL-запрос
C) Компоненты и связи между ними
D) Инструкция пользователя
E) Пример оформления с использованием CSS
ANSWER: C) Компоненты и связи между ними

145. Ключевые аспекты, важные при оценке архитектурного решения
A) Быстрота набора текста на клавиатуре
B) Количество подключённых файлов стилей
C) Совместимость, масштабируемость, безопасность
D) Настройка протокола электронной почты
E) Применение изображений в интерфейсе
ANSWER: C) Совместимость, масштабируемость, безопасность

146. Подход, обеспечивающий интеграцию с внешними системами
A) CSS
B) Плагины
C) API
D) UI
E) HTML
ANSWER: C) API

147. Обозначение DIP в принципах SOLID
A) Data Integration Principle
B) Direct Implementation Process
C) Dependency Inversion Principle
D) Default Interface Property
E) Database Interaction Pattern
ANSWER: C) Dependency Inversion Principle

148. Понятие архитектурной документации
A) Список участников проекта
B) График отпусков
C) Описание компонентов и решений архитектуры
D) Отчет о расходах
E) Перечень всех файлов проекта в каталоге
ANSWER: C) Описание компонентов и решений архитектуры

149. Шаблон проектирования, относящийся к структурным
A) Observer
B) Factory
C) Adapter
D) Strategy
E) Command
ANSWER: C) Adapter

150. Элементы стратегии резервного копирования
A) Принудительное удаление ненужных файлов системы
B) Разделение таблиц стилей по модулям проекта
C) Частота копирования, хранение и восстановление
D) Минификация и сжатие исходного проекта кода
E) Изменение внешнего вида логотипа в дизайне
ANSWER: C) Частота копирования, хранение и восстановление

151. Понятие отказоустойчивости в архитектуре
A) Полный отказ от работы сетевого соединения
B) Удаление всех пользовательских данных вручную
C) Способность системы продолжать работу при сбоях
D) Отключение графического интерфейса пользователя
E) Завершение работы системы с выходом из учётки
ANSWER: C) Способность системы продолжать работу при сбоях

152. Понятие кэширования в архитектуре
A) Хранение копий данных для ускорения доступа
B) Очистка данных
C) Сжатие файлов
D) Изоляция сети
E) Архивирование логов
ANSWER: A) Хранение копий данных для ускорения доступа

153. Понятие масштабирования по вертикали
A) Добавление новых серверов в кластер системы
B) Глубокая оптимизация исходного программного кода
C) Увеличение ресурсов одного существующего сервера
D) Удаление функциональных компонентов проекта
E) Сокращение элементов пользовательского интерфейса
ANSWER: C) Увеличение ресурсов одного существующего сервера

154. Принцип архитектуры облегчает миграцию на новые технологии
A) Жёсткая интеграция всех компонентов между собой
B) Сильная связанность между сервисами системы
C) Слабая связанность и модульная архитектура
D) Централизованное управление логикой приложения
E) Жёсткая типизация всех передаваемых данных
ANSWER: C) Слабая связанность и модульная архитектура

155. Основные принципы проектирования RESTful API
A) Использование формата XML и протокола FTP
B) Взаимодействие с сервером только через POST
C) Применение стандартов HTTP и работы с ресурсами
D) Прямая связь REST API с базой данных напрямую
E) Отображение информации с помощью статического HTM
ANSWER: C) Применение стандартов HTTP и работы с ресурсами

156. Понятие управления конфигурацией в архитектуре
A) Настройка внешнего вида с помощью CSS
B) Учет и контроль всех изменений компонентов
C) Замена логотипа компании на новый вариант
D) Копирование нужных данных напрямую вручную
E) Проверка грамматики в тексте интерфейса
ANSWER: B) Учет и контроль всех изменений компонентов

157. Принцип из SOLID, помогающий избежать зависимости от конкретных реализаций
A) SRP
B) LSP
C) OCP
D) ISP
E) DIP
ANSWER: E) DIP

158. Загрузка CSV-файла в DataFrame Pandas выполняется методом
A. df.load_csv()
B. pd.read_json()
C. pd.read_csv()
D. df.import()
E. pd.open_csv()
ANSWER: C. pd.read_csv()

159. Фильтрация DataFrame по условию в Pandas осуществляется с помощью
A. df.where()
B. df.filter()
C. df.query()
D. df.loc[...]
E. df.select()
ANSWER: D. df.loc[...]

160. Группировка данных по столбцу в Pandas выполняется методом
A. df.groupby()
B. df.aggregate()
C. df.group()
D. df.split()
E. df.segment()
ANSWER: A. df.groupby()

161. Применение функций агрегации к сгруппированным данным осуществляется методом
A. df.groupby().apply()
B. df.groupby().agg()
C. df.aggregate().group()
D. df.summary()
E. df.reduce()
ANSWER: B. df.groupby().agg()

162. Слияние двух DataFrame по ключевому столбцу выполняется функцией
A. pd.concat()
B. pd.merge()
C. df.join()
D. pd.combine()
E. df.append()
ANSWER: B. pd.merge()

163. Объединение DataFrame по вертикали выполняется с помощью
A. pd.merge()
B. df.join()
C. pd.concat()
D. df.combine_first()
E. pd.stack()
ANSWER: C. pd.concat()

164. Удаление дубликатов строк в Pandas достигается методом
A. df.drop()
B. df.remove_duplicates()
C. df.drop_duplicates()
D. df.unique()
E. df.clean()
ANSWER: C. df.drop_duplicates()

165. Заполнение пропусков в DataFrame значением выполняется методом
A. df.fillna()
B. df.dropna()
C. df.replace()
D. df.interpolate()
E. df.na()
ANSWER: A. df.fillna()

166. Удаление строк с пропусками осуществляется методом
A. df.drop()
B. df.dropna()
C. df.remove_na()
D. df.clean_na()
E. df.filter_na()
ANSWER: B. df.dropna()

167. Изменение порядка столбцов в DataFrame выполняется методом
A. df.transpose()
B. df.swapaxes()
C. df.reindex(columns=...)
D. df.move()
E. df.sort_index()
ANSWER: C. df.reindex(columns=...)

168. Добавление нового столбца в DataFrame делается через
A. df.add_column()
B. df['new'] = ...
C. df.insert()
D. df.assign()
E. df.append()
ANSWER: B. df['new'] = ...

169. Переименование столбцов в DataFrame выполняется методом
A. df.rename_columns()
B. df.rename()
C. df.set_names()
D. df.columns()
E. df.rename_index()
ANSWER: B. df.rename()

170. Сортировка DataFrame по значению столбца производится методом
A. df.order_by()
B. df.sort_index()
C. df.sort_values()
D. df.rank()
E. df.arrange()
ANSWER: C. df.sort_values()

171. Сохранение DataFrame в Excel-файл выполняется методом
A. df.to_excel()
B. pd.write_excel()
C. df.save_excel()
D. df.to_xlsx()
E. pd.export_excel()
ANSWER: A. df.to_excel()

172. Кодирование категориальных признаков в Pandas выполняется методом
A. pd.get_dummies()
B. df.categorize()
C. df.encode()
D. df.to_numeric()
E. pd.label_encode()
ANSWER: A. pd.get_dummies()

173. Подсчёт уникальных значений в столбце DataFrame выполняется методом
A. df.count_unique()
B. df.nunique()
C. df.unique()
D. df.value_counts()
E. df.distinct()
ANSWER: D. df.value_counts()

174. Получение описательной статистики DataFrame выполняется методом
A. df.describe()
B. df.stats()
C. df.summary()
D. pd.describe()
E. df.info()
ANSWER: A. df.describe()

175. Вывод информации о DataFrame (типах столбцов) производится методом
A. df.describe()
B. df.info()
C. df.summary()
D. pd.info()
E. df.report()
ANSWER: B. df.info()

176. Чтение JSON-файла в DataFrame выполняется методом
A. pd.read_csv()
B. df.load_json()
C. pd.read_json()
D. df.json_to_df()
E. pd.parse_json()
ANSWER: C. pd.read_json()

177. Конвертация индекса DataFrame в столбец выполняется методом
A. df.to_column()
B. df.reset_index()
C. df.unindex()
D. df.move_index()
E. df.export_index()
ANSWER: B. df.reset_index()

178. Преобразование столбца в datetime-тип осуществляется функцией
A. pd.to_time()
B. pd.to_datetime()
C. df.astype('datetime')
D. df.to_date()
E. df.to_timedelta()
ANSWER: B. pd.to_datetime()

179. Чтение Excel-файла в DataFrame выполняется методом
A. pd.read_excel()
B. df.load_excel()
C. pd.open_excel()
D. df.to_excel()
E. pd.read_xlsx()
ANSWER: A. pd.read_excel()

180. Построение графика линии в Pandas через DataFrame df делается методом
A. df.plot_line()
B. df.plot(kind='line')
C. pd.plot(df)
D. df.plot_line_chart()
E. df.plot_line()
ANSWER: B. df.plot(kind='line')

181. Преобразование DataFrame в словарь выполняется методом
A. df.to_dict()
B. pd.to_dict()
C. df.dict()
D. df.as_dict()
E. df.to_map()
ANSWER: A. df.to_dict()

182. Создание сводной таблицы в Pandas достигается методом
A. df.pivot()
B. df.pivot_table()
C. pd.table()
D. df.table()
E. pd.pivot()
ANSWER: B. df.pivot_table()

183. Установка индекса DataFrame по столбцу выполняется методом
A. df.set_index()
B. df.use_index()
C. df.index_column()
D. df.change_index()
E. df.indexify()
ANSWER: A. df.set_index()

184. Чтение HTML-таблицы в DataFrame выполняется функцией
A. pd.read_html()
B. df.read_html()
C. pd.parse_html()
D. df.read_table()
E. pd.fetch_html()
ANSWER: A. pd.read_html()

185. Запуск тестов в pytest выполняется командой
A. python -m pytest
B. pytest.run()
C. python pytest
D. pytest tests/
E. run pytest
ANSWER: A. python -m pytest

186. Маркировка теста как пропущенного в pytest достигается декоратором
A. @pytest.skip
B. @skip
C. @pytest.mark.skip
D. @skip_test
E. @pytest.mark.skipif
ANSWER: C. @pytest.mark.skip

187. Проверка равенства в unittest выполняется методом
A. assertEqual()
B. assertEquals()
C. assert()
D. assert_equals()
E. checkEqual()
ANSWER: A. assertEqual()

188. Определение тест-кейса в unittest выполняется объявлением класса, наследующего
A. unittest.TestCase
B. unittest.Case
C. TestCase.Base
D. Test.Base
E. unittest.Test
ANSWER: A. unittest.TestCase

189. Запуск конкретного теста unittest по имени выполняется через
A. python -m unittest path.to.TestCase.method
B. unittest.run(path.to.TestCase.method)
C. python -m test path.to.TestCase.method
D. python unittest path.to.TestCase.method
E. python -m unittest discover TestCase.method
ANSWER: A. python -m unittest path.to.TestCase.method

190. Определение фонового задания в Celery достигается с помощью декоратора
A. @celery.task
B. @app.task
C. @celery.background
D. @task
E. @app.background
ANSWER: B. @app.task

191. Отправка задачи Celery в очередь выполняется методом
A. task.call()
B. task.delay()
C. task.apply()
D. task.send()
E. task.execute()
ANSWER: B. task.delay()

192. Подключение брокера Redis в Celery настраивается параметром
A. broker_url
B. redis_uri
C. broker_connection
D. redis_broker
E. celery_broker_url
ANSWER: A. broker_url

193. Запуск Celery worker производится командой
A. celery run worker
B. celery worker --app=proj
C. python -m celery worker
D. celery start worker
E. start celery worker
ANSWER: B. celery worker --app=proj

194. Определение схемы в GraphQL с помощью Ariadne выполняется функцией
A. make_executable_schema()
B. create_schema()
C. build_schema()
D. init_schema()
E. graphql_schema()
ANSWER: A. make_executable_schema()

195. Обработка запроса GraphQL в FastAPI с помощью Strawberry достигается декоратором
A. @strawberry.query
B. @graphql.query
C. @fastapi.query
D. @strawberry.resolver
E. @app.query
ANSWER: A. @strawberry.query

196. Определение поля для запроса в Graphene выполняется в классе
A. class Query(ObjectType)
B. class Query(GraphQL)
C. class Query(graphene.Schema)
D. class Schema(Query)
E. class Query(Field)
ANSWER: A. class Query(ObjectType)

197. Запуск GraphQL сервера с помощью Ariadne в ASGI-приложении выполняется вызовом
A. GraphQL(app)
B. graphql_app(schema)
C. make_asgi_app(schema)
D. create_app(schema)
E. app.graphql(schema)
ANSWER: B. graphql_app(schema)

198. Создание виртуального окружения с использованием virtualenvwrapper выполняется командой
A. mkvirtualenv env
B. virtualenv env
C. createenv env
D. makeenv env
E. newenv env
ANSWER: A. mkvirtualenv env

199. Установка зависимостей проекта из файла requirements.txt выполняется командой
A. pip install requirements.txt
B. pip install -r requirements.txt
C. pip install --file requirements.txt
D. pip install requirements
E. pip install < requirements.txt
ANSWER: B. pip install -r requirements.txt

200. Обновление пакета через pip выполняется командой
A. pip update package
B. pip install package --upgrade
C. pip upgrade package
D. pip install --update package
E. pip reinstall package
ANSWER: B. pip install package --upgrade

201. Удаление пакета через pip выполняется командой
A. pip uninstall package
B. pip remove package
C. pip delete package
D. pip drop package
E. pip clear package
ANSWER: A. pip uninstall package

202. Вывод списка установленных пакетов pip производится командой
A. pip list
B. pip show
C. pip freeze
D. pip status
E. pip installed
ANSWER: A. pip list

203. Просмотр информации о пакете через pip осуществляется командой
A. pip info package
B. pip show package
C. pip details package
D. pip inspect package
E. pip describe package
ANSWER: B. pip show package

204. Запуск приложения Django выполняется командой
A. python manage.py run
B. python manage.py start
C. python manage.py runserver
D. django runserver
E. manage.py runserver
ANSWER: C. python manage.py runserver

205. Создание нового приложения в Django выполняется командой
A. python manage.py startapp appname
B. django createapp appname
C. python manage.py create appname
D. python manage.py newapp appname
E. django start app appname
ANSWER: A. python manage.py startapp appname

206. Применение миграций в Django выполняется командой
A. python manage.py migrate
B. python manage.py makemigrations
C. django migrate
D. python manage.py syncdb
E. python manage.py apply
ANSWER: A. python manage.py migrate

207. Создание файлов миграций в Django выполняется командой
A. python manage.py create migrations
B. python manage.py makemigrations
C. python manage.py newmigrations
D. django makemigrations
E. python manage.py genmigrations
ANSWER: B. python manage.py makemigrations

208. Определение URL-конфигурации в Django осуществляется в файле
A. urls.py
B. routes.py
C. config.py
D. views.py
E. settings.py
ANSWER: A. urls.py

209. Рендеринг данных в JSON в Django REST Framework осуществляется с помощью класса
A. JSONRenderer
B. ModelSerializer
C. HyperlinkedModelSerializer
D. JSONResponse
E. JSONEncoder
ANSWER: A. JSONRenderer

210. Аутентификация в Django REST Framework через токен выполняется пакетом
A. SessionAuthentication
B. BasicAuthentication
C. TokenAuthentication
D. JWTAuthentication
E. OAuth2Authentication
ANSWER: C. TokenAuthentication

211. Генерация JWT-токена в FastAPI достигается с помощью библиотеки
A. fastapi_jwt
B. pyjwt
C. jwt_fastapi
D. fastapi-auth
E. authlib
ANSWER: B. pyjwt

212. Подключение CORS в FastAPI осуществляется через мидлварь
A. CORSMiddleware
B. CORSHandler
C. CORSMiddlewareFastAPI
D. FastAPICORSMiddleware
E. CORSConfig
ANSWER: A. CORSMiddleware

213. Установка точки останова для отладки в Python выполняется вызовом функции
A. debug()
B. pdb.set_trace()
C. breakpoint()
D. trace()
E. pdb.start()
ANSWER: C. breakpoint()

214. Ввод пользователя в Python читается функцией
A. input()
B. raw_input()
C. read()
D. scanf()
E. get()
ANSWER: A. input()

215. Форматирование строк f-строками в Python обозначается префиксом
A. r
B. f
C. s
D. b
E. u
ANSWER: B. f

216. Проверка наличия подстроки в строке выполняется оператором
A. in
B. contains
C. has
D. find
E. index
ANSWER: A. in

217. Создание таймера задержки выполнения в asyncio осуществляется вызовом
A. asyncio.sleep()
B. time.sleep()
C. asyncio.wait()
D. asyncio.delay()
E. asyncio.pause()
ANSWER: A. asyncio.sleep()

218. Запуск корутины в asyncio на уровне скрипта производится функцией
A. asyncio.run()
B. loop.start()
C. loop.run()
D. asyncio.start()
E. asyncio.execute()
ANSWER: A. asyncio.run()

219. Получение текущего цикла событий asyncio выполняется методом
A. asyncio.get_current_loop()
B. asyncio.get_event_loop()
C. loop.current()
D. asyncio.current_loop()
E. loop.get()
ANSWER: B. asyncio.get_event_loop()

220. Отправка HTTP-запроса в асинхронном режиме через httpx выполняется методом
A. httpx.get_async()
B. httpx.AsyncClient().get()
C. httpx.get()
D. httpx.request()
E. httpx.fetch()
ANSWER: B. httpx.AsyncClient().get()

221. Обработка исключений в корутине asyncio выполняется через
A. try-except внутри async def
B. except_async
C. on_error callback
D. catch keyword
E. except_asyncio
ANSWER: A. try-except внутри async def

222. Создание простого TCP-сервера в Python Socket достигается методом
A. socket.bind() + socket.listen()
B. socket.connect() + socket.listen()
C. socket.open() + socket.accept()
D. socket.start() + socket.run()
E. socket.init() + socket.listen()
ANSWER: A. socket.bind() + socket.listen()

223. Принятие входящего соединения в сокете выполняется методом
A. sock.receive()
B. sock.accept()
C. sock.listen()
D. sock.connect()
E. sock.open()
ANSWER: B. sock.accept()

224. Отправка данных через сокет выполняется методом
A. sock.send()
B. sock.write()
C. sock.push()
D. sock.transmit()
E. sock.emit()
ANSWER: A. sock.send()

225. Кодирование данных в base64 в Python достигается модулем
A. base64
B. encoding
C. codec
D. binascii
E. codecs
ANSWER: A. base64

226. Шифрование симметричным ключом в Python можно выполнить через библиотеку
A. cryptography
B. hashlib
C. hmac
D. ssl
E. oscrypto
ANSWER: A. cryptography

227. Вычисление SHA-256 хэша строки в Python выполняется модулем
A. hashlib.sha256()
B. crypto.sha256()
C. ssl.sha256()
D. hmac.sha256()
E. base64.sha256()
ANSWER: A. hashlib.sha256()

228. Подключение переменных окружения в Python выполняется модулем
A. os.environ
B. env.load()
C. dotenv.load_dotenv()
D. configparser
E. settings.load()
ANSWER: C. dotenv.load_dotenv()

229. Чтение переменной окружения выполняется через
A. os.get('VAR')
B. os.getenv()
C. os.env()
D. os.environ.get()
E. os.env.get()
ANSWER: D. os.environ.get()

230. Загрузка параметров из YAML-файла в Python выполняется модулем
A. json
B. yaml.safe_load()
C. configparser
D. toml
E. xml.etree
ANSWER: B. yaml.safe_load()

231. Создание и активация виртуального окружения с Conda выполняется командами
A. conda env create и conda activate
B. conda create env и activate
C. virtualenv env и source env/bin/activate
D. conda new env и conda use
E. conda install env и conda activate
ANSWER: A. conda env create и conda activate

232. Публикация пакета в PyPI выполняется командой
A. twine upload dist/*
B. pip publish
C. setup.py upload
D. python publish
E. pip twine upload
ANSWER: A. twine upload dist/*

233. Определение точки входа в пакете Python задаётся в файле
A. setup.cfg
B. pyproject.toml
C. setup.py через entry_points
D. requirements.txt
E. setup.ini
ANSWER: C. setup.py через entry_points

234. Запуск контейнера Docker выполняется командой
A. docker start image
B. docker run image
C. docker create image
D. docker build image
E. docker init image
ANSWER: B. docker run image

235. Сборка Docker-образа из Dockerfile выполняется командой
A. docker build .
B. docker create .
C. docker run .
D. docker compile .
E. docker make .
ANSWER: A. docker build .

236. Просмотр запущенных контейнеров Docker осуществляется командой
A. docker containers
B. docker list
C. docker ps
D. docker status
E. docker show
ANSWER: C. docker ps

237. Остановка контейнера Docker выполняется командой
A. docker stop container
B. docker kill container
C. docker pause container
D. docker halt container
E. docker end container
ANSWER: A. docker stop container

238. Удаление неиспользуемых Docker-образов очищает пространство командой
A. docker clean
B. docker prune images
C. docker images prune
D. docker image prune
E. docker rmi
ANSWER: D. docker image prune

239. Определение сервисов в Docker Compose задаётся в файле
A. docker-compose.json
B. docker-compose.yml
C. Dockerfile
D. compose.yml
E. docker.services
ANSWER: B. docker-compose.yml

240. Запуск Docker Compose выполняется командой
A. docker-compose up
B. docker compose start
C. docker-compose run
D. docker compose exec
E. compose up
ANSWER: A. docker-compose up

241. Остановка Docker Compose выполняется командой
A. docker-compose down
B. docker-compose stop
C. docker compose down
D. docker compose stop
E. compose down
ANSWER: A. docker-compose down

242. Создание сети Docker выполняется командой
A. docker network create
B. docker network new
C. docker create network
D. docker network add
E. docker network init
ANSWER: A. docker network create

243. Просмотр сетей Docker осуществляется командой
A. docker networks
B. docker network ls
C. docker network list
D. docker ls networks
E. docker show networks
ANSWER: B. docker network ls

244. Удаление сети Docker выполняется командой
A. docker network rm
B. docker network delete
C. docker remove network
D. docker network remove
E. docker delete network
ANSWER: A. docker network rm

245. Определение переменных окружения в Docker Compose выполняется через
A. env_file
B. environment
C. variables
D. env_vars
E. docker_env
ANSWER: B. environment

246. Сборка отдельных сервисов в Docker Compose выполняется командой
A. docker-compose up service
B. docker-compose build service
C. docker compose build service
D. docker-compose create service
E. docker compose up service
ANSWER: B. docker-compose build service

247. Запуск контейнера Docker в фоновом режиме производится флагом
A. -d
B. -b
C. -bg
D. --detach
E. --background
ANSWER: A. -d

248. Создание Kubernetes пода определяется объектом
A. Deployment
B. Pod
C. Service
D. ReplicaSet
E. StatefulSet
ANSWER: B. Pod

249. Масштабирование Deployment в Kubernetes выполняется командой
A. kubectl scale deployment
B. kubectl resize deployment
C. kubectl set replicas
D. kubectl scale pods
E. kubectl deploy scale
ANSWER: A. kubectl scale deployment

250. Применение конфигурации Kubernetes из файла выполняется командой
A. kubectl set -f file.yaml
B. kubectl create -f file.yaml
C. kubectl apply -f file.yaml
D. kubectl run -f file.yaml
E. kubectl launch -f file.yaml
ANSWER: C. kubectl apply -f file.yaml

251. Получение списка подов в Kubernetes осуществляется командой
A. kubectl pods
B. kubectl get pods
C. kubectl list pods
D. kubectl ps
E. kubectl describe pods
ANSWER: B. kubectl get pods

252. Удаление ресурса в Kubernetes выполняется командой
A. kubectl rm resource
B. kubectl delete -f resource.yaml
C. kubectl remove resource
D. kubectl destroy resource
E. kubectl delete resource
ANSWER: B. kubectl delete -f resource.yaml

253. Создание сервиса в Kubernetes производится манифестом с полем
A. type: NodePort
B. type: LoadBalancer
C. type: ClusterIP
D. apiVersion: v1
E. kind: Service
ANSWER: E. kind: Service

254. Обновление Deployment в Kubernetes без простоев выполняется стратегией
A. Recreate
B. RollingUpdate
C. BlueGreen
D. Canary
E. InPlace
ANSWER: B. RollingUpdate

255. Определение секретов в Kubernetes задаётся объектом
A. kind: ConfigMap
B. kind: Secret
C. kind: Entry
D. kind: Env
E. kind: Credentials
ANSWER: B. kind: Secret

256. Мониторинг кластера Kubernetes можно осуществлять через инструмент
A. Prometheus
B. Grafana
C. KubeCTL
D. Helm
E. Istio
ANSWER: A. Prometheus

257. Управление пакетами Helm Charts в Kubernetes выполняется командой
A. helm install chart
B. helm deploy chart
C. helm apply chart
D. helm run chart
E. helm use chart
ANSWER: A. helm install chart

258. Подключение слота в PyQt выполняется с помощью
A. Применить метод bind
B. Соединить метод link
C. Использовать метод connect
D. Соединить метод couple
E. Привязать метод attach
ANSWER: C. Использовать метод connect

259. Получение осей в Matplotlib осуществляется через вызов функции
A. Применить plt.plot функцию
B. Вызвать plt.subplots функцию
C. Вызвать plt.clear метод
D. Использовать plt.show метод
E. Вызвать fig.add_subplot
ANSWER: B. Вызвать plt.subplots функцию

260. Фильтрация уникальных записей в Django ORM выполняется методом
A. Использовать queryset.only метод
B. Привязать queryset.filter_unique
C. Применить queryset.distinct
D. Применить queryset.exclude метод
E. Вызвать queryset.unique метод
ANSWER: C. Применить queryset.distinct

261. Определение модели ответа в FastAPI задаётся параметром
A. Задать response_type=Class
B. Указать response_model=Model
C. Применить output_model=Class
D. Использовать response_body=Class
E. Указать response_json=Schema
ANSWER: B. Указать response_model=Model

262. Обработка файлов во Flask производится через обращение к атрибуту
A. Вызвать request.json[file]
B. Использовать request.files[file]
C. Применить request.body[file]
D. Вызвать request.data[file]
E. Использовать request.form[file]
ANSWER: B. Использовать request.files[file]

263. Объявление зависимости в FastAPI осуществляется через
A. Применить Inject(async_func)
B. Вызвать Provide(async_func)
C. Связать Link(async_func)
D. Вызвать Use(async_func)
E. Использовать Depends(async_func)
ANSWER: E. Использовать Depends(async_func)

264. Сохранение графика в файл в Matplotlib выполняется методом
A. Применить plt.export('имя')
B. Вызвать plt.savefig('имя')
C. Вызвать plt.write('имя')
D. Привязать plt.store('имя')
E. Использовать plt.save('имя')
ANSWER: B. Вызвать plt.savefig('имя')

265. Установка заголовка окна в PyQt выполняется методом
A. Вызвать window.title()
B. Использовать window.header()
C. Использовать setWindowTitle()
D. Привязать setHeader()
E. Применить setTitle()
ANSWER: C. Использовать setWindowTitle()

266. Определение модели в Django осуществляется объявлением класса, наследующего
A. class Model(CoreModel)
B. class Model(models.Model)
C. class Model(AppModel)
D. class Model(DataModel)
E. class Model(BaseModel)
ANSWER: B. class Model(models.Model)

267. Задание цвета пера RGB в Turtle производится вызовом метода
A. Использовать color_rgb(r,g,b)
B. Привязать set_rgb_color(r,g,b)
C. Вызвать pencolor((r,g,b))
D. Вызвать rgb_color(r,g,b)
E. Применить setcolor_rgb(r,g,b)
ANSWER: C. Вызвать pencolor((r,g,b))

268. Создание модели сериализатора в Django REST Framework выполняется с помощью класса
A. Использовать class Serializer
B. Применить SerializerMethodField
C. Вызвать ModelSerializer класс
D. Привязать ListSerializer класс
E. Задать HyperlinkedModelSerializer класс
ANSWER: C. Вызвать ModelSerializer класс

269. Добавление легенды в Matplotlib выполняется вызовом функции
A. Вызвать plt.legend()
B. Применить fig.legend()
C. Использовать ax.legend()
D. Привязать subplot.legend()
E. Задать legend.set()
ANSWER: A. Вызвать plt.legend()

270. Подключение сигнала clicked() в PyQt осуществляется через
A. Привязать clicked.connect()
B. Вызвать signal.connect(clicked)
C. Использовать button.clicked.connect()
D. Применить connect.clicked(button)
E. Задать clicked.attach(button)
ANSWER: C. Использовать button.clicked.connect()

271. Создание макета в Tkinter выполняется при помощи менеджера
A. Использовать Grid менеджер
B. Применить Pack менеджер
C. Вызвать Place менеджер
D. Привязать Layout менеджер
E. Задать Anchor менеджер
ANSWER: A. Использовать Grid менеджер

272. Установка размера окна в PyQt производится методом
A. Использовать resize(width,height)
B. Применить setSize(width,height)
C. Вызвать window.size(width,height)
D. Привязать sizePolicy(width,height)
E. Задать adjustSize(width,height)
ANSWER: A. Использовать resize(width,height)

273. Очистка осей в Matplotlib осуществляется через функцию
A. Вызвать ax.clear()
B. Использовать fig.clear()
C. Применить plt.clf()
D. Привязать plt.clean()
E. Задать clear_axes()
ANSWER: C. Применить plt.clf()

274. Обработка JSON в Flask производится методом
A. Вызвать request.get_json()
B. Использовать request.json()
C. Применить request.data()
D. Привязать request.body()
E. Задать request.form()
ANSWER: A. Вызвать request.get_json()

275. Валидация заголовков в FastAPI выполняется с помощью параметра
A. Использовать Header() параметр
B. Применить Depends() параметр
C. Вызвать Body() параметр
D. Привязать Cookie() параметр
E. Задать Query() параметр
ANSWER: A. Использовать Header() параметр

276. Создание главного окна в Tkinter выполняется через класс
A. Вызвать Tk() класс
B. Использовать Window() класс
C. Применить App() класс
D. Привязать Main() класс
E. Задать Frame() класс
ANSWER: A. Вызвать Tk() класс

277. Определение стиля линий в Matplotlib осуществляется параметром
A. Использовать linestyle параметр
B. Применить linecolor параметр
C. Вызвать linewidth параметр
D. Привязать markerstyle параметр
E. Задать fillstyle параметр
ANSWER: A. Использовать linestyle параметр

278. Контекстный менеджер with в Python обеспечивает функционал
A. Обрабатывает синхронные события
B. Закрывает ресурс автоматически
C. Перехватывает сетевые запросы
D. Откладывает выполнение функций
E. Создает новый поток выполнения
ANSWER: B. Закрывает ресурс автоматически

279. Обработка исключений в Python выполняется с помощью конструкции
A. Применить блок catch
B. Использовать блок finally
C. Вызвать блок else
D. Использовать блок try-except
E. Использовать блок handle
ANSWER: D. Использовать блок try-except

280. Создание виртуального окружения Python выполняется командой
A. python -m env
B. pip create venv
C. python run venv
D. python -m venv
E. pip install virtualenv
ANSWER: D. python -m venv

281. Подключение middleware в Django производится добавлением класса в
A. Зарегистрировать app в INSTALLED_APPS
B. Добавить класс в MIDDLEWARE
C. Использовать decorator middleware
D. Импортировать module middleware
E. Вызвать метод add_middleware
ANSWER: B. Добавить класс в MIDDLEWARE

282. Настройка статических файлов в Django выполняется путём указания параметра
A. Включить DEBUG режим в settings
B. Добавить APP_DIRS в settings
C. Указать STATIC_URL в settings
D. Задать MEDIA_ROOT в settings
E. Указать TEMPLATES_DIRS в settings
ANSWER: C. Указать STATIC_URL в settings

283. Изменение цвета линии в Matplotlib осуществляется через параметр
A. Использовать параметр linewidth
B. Применить маркер marker
C. Задать параметр linestyle
D. Использовать параметр color
E. Применить параметр markeredge
ANSWER: D. Использовать параметр color

284. Объявление собственного сигнала в PyQt производится с помощью класса
A. Применить класс QtSignal
B. Использовать класс Signal
C. Применить класс customSignal
D. Использовать класс pyqtSignal
E. Вызвать метод defineSignal
ANSWER: D. Использовать класс pyqtSignal

285. Связывание функции с событием нажатия кнопки в Tkinter выполняется через
A. Использовать метод connect
B. Вызвать bind событие
C. Применить метод attach
D. Вызвать onClick метод
E. Использовать метод command
ANSWER: E. Использовать метод command

286. Повторение действий в Turtle осуществляется с помощью конструкции
A. Применить метод repeat
B. Использовать цикл while
C. Использовать функцию repeat
D. Использовать цикл for
E. Вызвать функцию loop
ANSWER: D. Использовать цикл for

287. Статус-код 201 в REST означает
A. Принят неполный запрос
B. Создан новый ресурс
C. Обновлен существующий ресурс
D. Ошибка клиента запроса
E. Успешный запрос GET
ANSWER: B. Создан новый ресурс

288. Создание генератора списка в Python выполняется через синтаксис
A. Использовать генератор словаря
B. Применить comprehension списка
C. Вызвать list.generator функции
D. Применить оператор yield
E. Применить map функции
ANSWER: B. Применить comprehension списка

289. Добавление аннотаций типов к функциям в Python выполняется по синтаксису
A. Применить comment синтаксис
B. Использовать PEP484 синтаксис
C. Вызвать typing.import функции
D. Применить dtype аннотации
E. Использовать type() функции
ANSWER: B. Использовать PEP484 синтаксис

290. Выполнение агрегирования в Django ORM осуществляется методом
A. Применить ORM.sum методов
B. Использовать queryset.aggregate функций
C. Применить SQL.raw методов
D. Вызвать queryset.annotate метода
E. Использовать ORM.filter функций
ANSWER: B. Использовать queryset.aggregate функций

291. Создание нескольких графиков в Matplotlib выполняется вызовом функции
A. Применить fig.add_axes
B. Использовать plt.subplot метод
C. Вызвать fig.create_axes
D. Вызвать plt.subplots функцию
E. Применить ax.plot_lines
ANSWER: D. Вызвать plt.subplots функцию

292. Запуск фонового потока в PyQt производится через использование класса
A. Через threading.Thread напрямую
B. Использовать QThreadPool класса
C. Вызвать Threading.thread метода
D. Применить async Thread функции
E. Использовать multiprocessing.Process класса
ANSWER: B. Использовать QThreadPool класса

293. Рисование прямоугольника в Tkinter Canvas выполняется методом
A. Применить Tk.draw_rectangle метода
B. Использовать GUI.create_rectangle метод
C. Вызвать canvas.create_rectangle метод
D. Применить Canvas.draw_rectangle метод
E. Вызвать window.create_rectangle метода
ANSWER: C. Вызвать canvas.create_rectangle метод

294. Установка штампа в Turtle производится методом
A. Вызвать turtle.clone метод
B. Применить turtle.circle функцию
C. Вызвать turtle.stamp метод
D. Использовать turtle.write метод
E. Применить turtle.goto метод
ANSWER: C. Вызвать turtle.stamp метод

295. Версионирование API обычно осуществляется через
A. Применить Cookie версии
B. Использовать URI версии
C. Применить HTTP заголовки
D. Вызвать Query параметров
E. Использовать MIMEタイプ
ANSWER: B. Использовать URI версии

296. Регистрация Blueprint во Flask выполняется методом
A. Использовать app.include_blueprint метода
B. Вызвать app.add_blueprint метода
C. Применить register_blueprint метода
D. Использовать Blueprint.connect функции
E. Применить app.attach_blueprint метода
ANSWER: C. Применить register_blueprint метода

297. Настройка аутентификации OAuth2 в FastAPI выполняется через схему
A. Применить HTTPBearer схемы
B. Использовать OAuth2PasswordBearer схемы
C. Применить OAuth2PasswordRequest формата
D. Вызвать OAuth2ClientCredentials класса
E. Использовать APIKeyHeader схемы
ANSWER: B. Использовать OAuth2PasswordBearer схемы

298. Создание асинхронной функции в Python производится объявлением ключевого слова
A. Вызвать await метода
B. Вызвать thread функции
C. Использовать async def
D. Применить static def
E. Использовать sync def
ANSWER: C. Использовать async def

299. Добавление маршрута в Django urls осуществляется функцией
A. Использовать views() функции
B. Использовать url() схемы
C. Применить re_path() метода
D. Вызвать include() функции
E. Вызвать path() функции
ANSWER: E. Вызвать path() функции

300. Установка подписи оси X в Matplotlib выполняется методом
A. Применить grid() функции
B. Использовать xlabel() метода
C. Вызвать title() функции
D. Применить ylabel() метода
E. Использовать legend() метода
ANSWER: B. Использовать xlabel() метода