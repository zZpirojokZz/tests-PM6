1.	Получить последний элемент списка
A.	last()
B.	end()
C.	tail()
D.	[-1]
ANSWER: D

2.	 Результат кода
a = 4
print(a, 'a')
A.	A .44
B.	aa
C.	4a
D.	a4
ANSWER: C

3.	 Результат кода
my_dict = {1: [0, 1], 2: [2, 3], 3: [4, 5]}
print(my_dict[2][1])
A.	[0, 1], [2, 3]
B.	[2, 3]
C.	3
D.	5
ANSWER: C

4.	 Выберите правильно записанный оператор присваивания
A.	10 = х
B.	у = 7,8
C.	а = 5
D.	а == b + x
ANSWER: C

5.	 Оператор ввода
A.	input()
B.	print()
C.	int()
D.	random()
ANSWER: A

6.	Цикл с предусловием
A.	while
B.	for
C.	if
D.	print
ANSWER: A

7.	Операция нахождения остатка 
A.	%
B.	+
C.	/
D.	*
ANSWER: A

8.	Формальные параметры функции записываются
A.	В заголовке функции
B.	В теле функции
C.	При вызове функции
D.	В основной программе

ANSWER: A

9.	Функция len() возвращает
A.	Длину строки
B.	Случайное число
C.	Номер символа
D.	Модуль числа
ANSWER: A

10.	Способ подключения модуля к программе
A.	import math
B.	import math()
C.	import (math)
D.	import.math
ANSWER: A

11.	Создатель языка программирования Python
A.	Гвидо Ван Россум
B.	Дэвид Паттерсон
C.	Эрвин Дональд Кнут
D.	Джеймс Артур Гослинг
ANSWER: A

12.	а = 345. print(а//100) результат кода
A.	3
B.	5
C.	4
D.	34
ANSWER: A

13.	int(input()) 
A.	Вводится число с клавиатуры
B.	На экран выводится сообщение
C.	Вводится целое число с клавиатуры
D.	Вводятся символы с клавиатуры
ANSWER: C

14.	Значения в списках, заключённые в квадратные скобки и разделённые запятой
A.	Строки
B.	Числа
C.	Элементы
D.	Индексаторы
ANSWER: C

15.	Сортировка элементов списка по возрастанию
A.	sort()
B.	order()
C.	arrange()
D.	organize()
ANSWER: A

16.	Первой строкой в описании функции является
A.	Введение
B.	Инициализация
C.	Тело
D.	Заголовок
ANSWER: D

17.	Часть программы в функции
A.	Введение
B.	Инициализация
C.	Тело
D.	заголовок
ANSWER: C

18.	Чтобы выполнить функцию
A.	Вызывают
B.	Импортируют
C.	Определяют
D.	Экспортируют
ANSWER: A

19.	Условный оператор
A.	if
B.	do
C.	while
D.	for
ANSWER: A

20.	Логический оператор "И" 
A.	&&
B.	||
C.	!
D.	and
ANSWER: D

21.	Параметр, описанный в теле функции
A.	Глобальный
B.	Скрытый
C.	Формальный
D.	Локальный
ANSWER: D

22.	Логический оператор "ИЛИ" 
A.	&&
B.	||
C.	!
D.	or
ANSWER: D

23.	Логический оператор "НЕ" 
A.	&&
B.	||
C.	not
D.	and
ANSWER: C

24.	не равно 
A.	= =
B.	=
C.	!=
D.	>
ANSWER: C

25.	Начальное значение параметра "start" в функции range() 
A.	0
B.	1
C.	-1
D.	10
ANSWER: A

26.	Оператор прерывания 
A.	skip
B.	next
C.	break
D.	stop
ANSWER: C

27.	Функция, возвращающая действительные случайные числа в диапазоне от 0.0 до 1.0
A.	random()
B.	randint()
C.	uniform()
D.	random_integer()
ANSWER: A

28.	Значение функции range(3, 10, 2) 
A.	[3, 5, 7, 9]
B.	[2, 4, 6, 8]
C.	[3, 6, 9]
D.	[2, 5, 8]
ANSWER: A

29.	Значение функции range(5) 
A.	[0, 1, 2, 3, 4]
B.	[1, 2, 3, 4, 5]
C.	[0, 1, 2, 3, 4, 5]
D.	[1, 2, 3, 4, 5, 6]
ANSWER: A

30.	Команда для перехода к следующей итерации цикла while 
A.	next
B.	continue
C.	skip
D.	pass
ANSWER: B

31.	Выберите логическое выражение, которое проверяет, что переменная x находится в диапазоне от 0 до 55
A.	x > 0 or < 5
B.	x > 0 or x < =5
C.	x > 0 and x < 55
D.	x > 0 and < 5
ANSWER: C

32.	Комментарии 
A.	//
B.	--
C.	/*
D.	#
ANSWER: D

33.	Пустой список
A.	array[]
B.	array()
C.	[]
D.	{}
ANSWER: C

34.	Длина списка
A.	length()
B.	size()
C.	count()
D.	len()
ANSWER: D

35.	Результат кода
zeros = [0] * 10
print(len(zeros))
A.	10
B.	l2
C.	0
D.	100
ANSWER: A

36.	Результат кода
words = ['Hello', 'Python']
print('-'.join(words))
A.	Hello-Python
B.	Hello-Python-
C.	HelloPython-
D.	-HelloPython
ANSWER: A

37.	Результат кода 
numbers = [10, 20, 30, 40]
del numbers[0:6]
print(numbers)
A.	[20, 40]
B.	B.[30, 40]
C.	C.[10, 20]
D.	D.[]
ANSWER: D

38.	Результат кода
list1 = [[1, 8, 9], [4, 8, 12, 16], [0, 2, 7]]
print(list1[0][1] + list1[1][2] + list1[2][2])
A.	27
B.	5
C.	13
D.	38
ANSWER: A

39.	Результат кода
list1 = [[1, 8, 7, 4], [1, 3, 4, 5, 6], [2, 7, 2], [2, 6, 7, 8]]
print(max(list1))
A.	A.[1, 8, 7, 4]
B.	B.[2, 7, 2]
C.	C.[2, 6, 7, 8]
D.	D.[1, 3, 4, 5, 6]
ANSWER: B

40.	Результат кода
matrix  = [[1, 2, 8, 0],
           [-4, 1, 9, 4],
           [41, 71, 2, -2]]
print(matrix[2][3])
A.	9
B.	-2
C.	4
D.	2
ANSWER: B

41.	Количество элементов в кортеже numbers
numbers = (3, 5, 7, 9)
A.	4
B.	0
C.	5
D.	3
ANSWER: A

42.	Результат кода
names = ('Michael', 'John', 'Freddie')
print(names)
A.	'Michael', 'John', 'Freddie'
B.	('Michael', 'John', 'Freddie')
C.	["Michael", "John", "Freddie"]
D.	(Michael, John, Freddie)
ANSWER: B

43.	Результат кода
colors = ('red', 'green', 'blue')
colors[0] = 'black'
print(colors)
A.	ошибка
B.	('red', 'green', 'blue')
C.	('black', 'green', 'blue')
D.	('blue', 'black', 'green')
ANSWER: A

44.	Результат кода 
a = (3, 4, 5)
for i in range(3):
    a[i] += 3
print(sum(a))
A.	12
B.	21
C.	9
D.	ошибка
ANSWER: D

45.	Индекс числа 337 в кортеже numbers
numbers = (0, 1090, 7, 21, 17, 337, 22)
A.	5
B.	4
C.	6
D.	7
ANSWER: A

46.	Для вложенного кортежа numbers[0][1][1] будет равен
numbers = ((0, (9, 2)), (1, (4, 6, 3), (5, 2, 3), 8, 3))
A.	9
B.	2
C.	4
D.	1
ANSWER: B

47.	Индекс для доступа к первому элементу списка
A.	0
B.	1
C.	-1
D.	2
ANSWER: A

48.	Значение range(5) 
A.	[0, 1, 2, 3, 4]
B.	[1, 2, 3, 4, 5]
C.	[0, 1, 2, 3, 4, 5]
D.	[1, 2, 3, 4, 5, 6]
ANSWER: A

49.	Не натуралное число
A.	5
B.	2
C.	10
D.	-3
ANSWER: D

50.	Вещественное число
A.	-3
B.	10
C.	5
D.	1.2
ANSWER: D

51.	Комментарии
A.	//
B.	--
C.	/*
D.	#
ANSWER: D

52.	Пустой список
A.	array[]
B.	array()
C.	[]
D.	{}
ANSWER: C

53.	53.Результат кода
myset = set([1, 2, 2, 3, 4, 4, 4])
print(len(myset))
A.	7
B.	4
C.	5
D.	6
ANSWER: B

54.	Результат кода
myset = set('ъъ эээ юююю яяяяя')
print(len(myset))
A.	5
B.	15
C.	14
D.	4
ANSWER: A

55.	Результат кода
myset = {'Yellow', 'Orange', 'Black'}
print(myset[1])
A.	Yellow
B.	Orange
C.	Black
D.	ошибка
ANSWER: D

56.	Выберите способ добавить новое значение item в множество myset
A.	myset.add(item)
B.	myset.update(item)
C.	myset.append(item)
D.	myset.insert(item)
ANSWER: A

57.	Результат кода
myset = {'Yellow', 'Orange', 'Black'}
myset.add('Blue')
myset.add('Orange')
print(myset)
A.	{'Yellow', 'Black'}
B.	{'Blue', 'Orange', 'Yellow', 'Black'}
C.	{'Yellow', 'Orange', 'Black'}
D.	{'Blue', 'Orange', 'Yellow', 'Orange', 'Black'}
ANSWER: B

58.	Результат кода
myset = {'python'}
item = myset.pop()
print(item, len(myset))
A.	python 1
B.	python 0
C.	p5
D.	python 2
ANSWER: A

59.	Результат кода
myset = set('python')
item = myset.pop()
print(item, len(myset))
A.	p 5
B.	python 1
C.	p 0
D.	p 6
ANSWER: A

60.	Результат кода
myset = set()
item = myset.pop()
print(item)
A.	0
B.	-1
C.	set()
D.	ошибка
ANSWER: D

61.	Результат кода
myset = set()
for i in range(10):
    if i % 2 == 0:
        myset.add('even')
    else:
        myset.add('odd')
print(len(myset))
A.	1
B.	2
C.	4
D.	5
ANSWER: B

62.	Результат кода
set1 = {10, 20, 30, 40}
set2 = set(range(50))
print(set1.issubset(set2))
A.	True
B.	False
C.	boolean
D.	set2
ANSWER: A

63.	Результат кода
set1 = set('Stepik')
set2 = set('stepik')
print(set1.issubset(set2))
A.	True
B.	False
C.	boolean
D.	ошибка
ANSWER: B

64.	Результат кода
word = 'beegeek'
set1 = set(word*3)
set2 = set(word[::-1]*2 + 'stepik')
print(set1 < set2)
A.	False
B.	True
C.	ошибка
D.	boolean
ANSWER: B

65.	Результат кода
set1 = {1, 2, 3, 4, 5, 6, 7, 8}
list1 = [1, 2, 3, 4, 5]
print(set1.issuperset(list1))
A.	False
B.	True
C.	boolean
D.	[1, 2, 3, 4, 5]
ANSWER: B

66.	Результат кода
set1 = {'q', 'w', 'e', 'r', 't', 'y'}
list1 = ['y', 'w', 'r']
print(set1 >= list1)
A.	False
B.	True
C.	ошибка
D.	boolean
ANSWER: C

67.	Результат кода
set1 = set(range(1, 10))
set2 = set(range(10, 20))
print(set1.isdisjoint(set2))
A.	False
B.	True
C.	ошибка
D.	boolean
ANSWER: B 

68.	Результат кода
set1 = {1, 2, 3, 4, 5}
set2 = frozenset(range(1, 6))
print(set1 == set2)
A.	ошибка
B.	False
C.	True
D.	equal
ANSWER: C

69.	Словари (тип dict) являются
A.	Изменяемыми
B.	Неизменяемыми
C.	Множествами
D.	Списками
ANSWER: A

70.	Результат кода
stuff = {1: 'ааа', 2: 'ббб', 3: 'ввв'}
print(stuff[3])
A.	ббб
B.	ввв
C.	ааа
D.	2
ANSWER: B

71.	Результат кода
my_dict = dict([('first', 1), ('second', 2), ('third', 3)])
print(my_dict)
A.	[('first', 100), ('second', 200), ('third', 300)]
B.	{1: 'first', 2: 'second', 3: 'third'}
C.	{'first': 1, 'second': 2, 'third': 3}
D.	{first: 1, second: 2, third: 3}
ANSWER: C

72.	Результат кода
my_dict = dict.fromkeys(['a', 'b', 'c'], -1)
print(my_dict['b'])
A.	-1
B.	c
C.	b
D.	a
ANSWER: A

73.	Результат кода 
my_dict = dict.fromkeys(['a', 'b', 'c'], -1)
print(my_dict['d'])
A.	a
B.	ошибка
C.	b
D.	c
ANSWER: B

74.	Результат кода
my_dict = {1: [0, 1], 2: [2, 3], 3: [4, 5]}
print(my_dict[2][1])
A.	[0, 1], [2, 3]
B.	[2, 3]
C.	3
D.	5
ANSWER: C

75.	Результат кода 
stuff = {1:'ааа', 2:'ббб', 3:'ввв', 4:'ггг'}
print(len(stuff))
A.	1
B.	3
C.	2
D.	4
ANSWER: D

76.	Результат кода
dict1 = {'key1':1, 'key2':2}
dict2 = {'key2':2, 'key1':1}
print(dict1 == dict2)
A.	False
B.	True
C.	ошибка
D.	11
ANSWER: B

77.	Результат кода
my_dict = {'foo': 100, 'bar': 200, 'baz': 300}
print(my_dict['bar':'baz'])
A.	(200, 300)
B.	[200, 300]
C.	200 300
D.	ошибка
ANSWER: D

78.	Результат кода 
dct = {'понедельник': 1, 'вторник': 2, 'среда': 3}
print(dct.get('понедельник', 'Не найдено'))
A.	3
B.	2
C.	6
D.	1 
ANSWER: D

79.	Результат кода
dct = {'понедельник': 1, 'вторник': 2, 'среда': 3}
print(dct.get('пятница', 'Не найдено'))
A.	5
B.	2
C.	6
D.	4
ANSWER: C

80.	Описание двумерного списка 
A.	[[ ]]
B.	[( )]
C.	{{ }}
D.	[{ }]
ANSWER: A

81.	Правильный способ получить возраст Темура из словаря students
students = {1: {'name': 'Тимур', 'age': '28', 'sex': 'Male'},
            2: {'name': 'Руслан', 'age': '22', 'sex': 'Male'},
            3: {'name': 'Соня', 'age': '25', 'sex': 'Female'}}
A.	students[0][1]
B.	students[0]['age']
C.	students[1]['age']
D.	students['Тимур']['age']
ANSWER: C

82.	Количество строк в двумерном списке в Python
A.	rows()
B.	row_count()
C.	len()
D.	count()
ANSWER: В

83.	Количество столбцов в двумерном списке в Python
A.	columns()
B.	col_count()
C.	len()
D.	count()
ANSWER: B

84.	Результат кода 
a = 82 // 3 ** 2 % 7
print(a)
A.	2
B.	3
C.	7
D.	82
ANSWER: A

85.	Результат кода
a = 4
print(a, 'a')
A.	44
B.	aa
C.	4a
D.	a4
ANSWER: C

86.	Результат кода
my_dict = {1: [0, 1], 2: [2, 3], 3: [4, 5]}
print(my_dict[2][1])
A.	[0, 1], [2, 3]
B.	[2, 3]
C.	3
D.	5
ANSWER: C

87.	Результат кода
from decimal import *
num = Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)
if num == 0:
    print('YES')
else:
    print('NO')
A.	YES
B.	YES YES
C.	NO
D.	NO NO
ANSWER: C

88.	Результат кода
def swap(a, b):
    a, b = b, a
a = 4
b = 3
swap(a, b)
print(a - b)
A.	-1
B.	4
C.	1
D.	3
ANSWER: C

89.	Результат кода
from fractions import *
num = Fraction(7, 71)
if num * 71 == 7:
    print('YES')
else:
    print('NO')
A.	YES
B.	NO
C.	NO NO
D.	YES YES
ANSWER: A

90.	Метод upper()
A.	Преобразует строку в нижний регистр
B.	Преобразует строку в верхний регистр 
C.	Удаляет пробелы в начале и в конце строки
D.	Проверяет, состоит ли строка только из букв
ANSWER: B

91.	Метод котроый проверяет, состоит ли строка только из цифр
A.	isalpha()
B.	isdigit() 
C.	isalnum()
D.	isnumeric()
ANSWER: B


92.	Какой результат будет у выражения
"hello world".replace("world", "Python")
A.	"hello world"
B.	"hello Python" 
C.	"helloPython"
D.	"hello World"
ANSWER: B

93.	Метод для удаления пробелов в начале и в конце строки
A.	strip() 
B.	split()
C.	rstrip()
D.	lstrip()
ANSWER: A

94.	Объединить список строк ["I", "love", "Python"] в одну строку с пробелами
A.	" ".join(["I", "love", "Python"]) 
B.	" ".split(["I", "love", "Python"])
C.	" ".append(["I", "love", "Python"])
D.	" ".concat(["I", "love", "Python"])
ANSWER: A

95.	Проверить, начинается ли строка с подстроки "Py"
A.	startswith("Py") 
B.	endswith("Py")
C.	find("Py")
D.	index("Py")
ANSWER: A

96.	Метод возвращает индекс первого вхождения подстроки "o" в строке "Hello"
A.	find("o") 
B.	index("o")
C.	count("o")
D.	position("o")
ANSWER: A

97.	Разбить строку "apple,banana,cherry" на список по запятой
A.	"apple,banana,cherry".split(",") 
B.	"apple,banana,cherry".join(",")
C.	"apple,banana,cherry".partition(",")
D.	"apple,banana,cherry".replace(",", " ")
ANSWER: A

98.	Проверить, состоит ли строка только из букв и цифр
A.	isalnum() 
B.	isalpha()
C.	isdigit()
D.	isnumeric()
ANSWER: A

99.	Метод count("a") для строки "banana" делает
A.	Проверяет, есть ли буква "a"
B.	Возвращает количество вхождений "a"
C.	Удаляет все буквы "a"
D.	Возвращает индекс первой буквы "a"
ANSWER: B

100.	Тип ошибки возникает при делении на ноль
A.	TypeError
B.	ValueError
C.	ZeroDivisionError 
D.	IndexError
ANSWER: C

101.	Блок который используется для обработки исключений 
A.	try-except 
B.	if-else
C.	for-while
D.	def-class
ANSWER: A

102.	блок finally делает
A.	Выполняется только при возникновении ошибки
B.	Выполняется независимо от того, была ошибка или нет 
C.	Прерывает выполнение программы
D.	Проверяет тип ошибки
ANSWER: B

103.	Тип ошибки возникает при попытке обратиться к элементу списка по недопустимому индексу
A.	IndexError 
B.	KeyError
C.	ValueError
D.	TypeError
ANSWER: A

104.	Тип ошибки который возникает, если переменная не определена
A.	NameError 
B.	TypeError
C.	ValueError
D.	KeyError
ANSWER: A

105.	Тип ошибки который возникает при попытке сложить число и строку, например 5 + "5"
A.	ValueError
B.	TypeError 
C.	ZeroDivisionError
D.	IndexError
ANSWER: B

106.	Подключиться к базе данных SQLite
A.	import sqlite3; conn = sqlite3.connect("mydb.db") 
B.	import psycopg2; conn = psycopg2.connect("mydb.db")
C.	import sqlite; conn = sqlite.connect("mydb.db")
D.	import database; conn = database.connect("mydb.db")
ANSWER: A

107.	Подключение к базе данных PostgreSQL 
A.	import psycopg2; conn = psycopg2.connect(dbname="mydb", user="user", password="pass", host="localhost") 
B.	import sqlite3; conn = sqlite3.connect("mydb")
C.	import pgsql; conn = pgsql.connect("mydb")
D.	import postgresql; conn = postgresql.connect("mydb")
ANSWER: A


108.	SQLAlchemy в Python
A.	Модуль для работы только с SQLite
B.	ORM-библиотека для работы с базами данных 
C.	Модуль для веб-разработки
D.	Инструмент для визуализации данных
ANSWER: B

109.	Создать соединение с базой данных через SQLAlchemy
A.	from sqlalchemy import create_engine; engine = create_engine("sqlite:///mydb.db") 
B.	import sqlite3; conn = sqlite3.connect("mydb.db")
C.	from sqlalchemy import session; session.connect("mydb.db")
D.	import sqlalchemy; engine = sqlalchemy.connect("mydb.db")
ANSWER: A

110.	Добавить новый объект (запись) в базу данных через SQLAlchemy
A.	session.add(obj); session.commit() 
B.	engine.add(obj)
C.	session.insert(obj)
D.	engine.commit(obj)
ANSWER: A

111.	Определение интеграции информационных систем:
A.	Организация обмена данными между различными приложениями 
B.	Выполнение операций обработки данных внутри отдельных модулей 
C.	Настройка функционирования компонентов программного обеспечения 
D.	Реализация пользовательских функций в программных интерфейсах
ANSWER: A

112.	Характеристика вертикальной интеграции:
A.	Интеграция компонентов через единый коммуникационный слой
B.	Соединение решений в соответствии с последовательностью уровней
C.	Использование стандартных интерфейсов для взаимодействия сервисов
D.	Передача структурированных сообщений через специализированный канал
ANSWER: B

113.	Характеристика горизонтальной интеграции:
A.	Объединение отдельных решений посредством единого коммуникационного механизма
B.	Взаимодействие функциональных компонентов, находящихся на одном уровне
C.	Передача структурированных данных между системами через файловый канал
D.	Преобразование и загрузка информации в соответствии с заданными сценариями
ANSWER: A

114.	Особенность интеграции точка-к-точке:
A.	Использование агента мониторинга
B.	Прямая связь между двумя системами
C.	Передача через очередь сообщений
D.	Шина данных как посредник
ANSWER: B

115.	ESB применяется в подходе интеграции:
A.	Через шину
B.	Точка-к-точке
C.	Через файлы
D.	Через API-маршруты
ANSWER: A

116.	Первый этап жизненного цикла интеграционного проекта:
A.	Мониторинг логов
B.	Анализ требований
C.	Финальное тестирование
D.	Настройка API Gateway
ANSWER: B

117.	Роль интеграции в цифровой трансформации:
A.	Обеспечение связности систем и процессов
B.	Уменьшение количества серверов
C.	Стандартизация UI
D.	Ускорение тестирования
ANSWER: A

118.	Компонент информационной системы:
A.	Панель мониторинга
B.	База данных
C.	Иконки интерфейса
D.	Документация
ANSWER: B

119.	Особенность клиент-серверной архитектуры:
A.	Разделение логики на независимые сервисы
B.	Разделение клиента и сервера
C.	Использование брокера сообщений
D.	Обязательное применение облака
ANSWER: B

120.	Особенность многоуровневой архитектуры:
A.	Только пользовательский интерфейс
B.	Объединение данных, логики и интерфейса в одном месте
C.	Разделение на уровни: данные, бизнес-логика, интерфейс
D.	Наличие только одного сервера
ANSWER: C

121.	Признак сервис-ориентированной архитектуры (SOA):
A.	Использование одной общей БД
B.	Сервисы с четкими контрактами
C.	Полное отсутствие API
D.	Зависимость модулей
ANSWER: B

122.	Особенность микросервисной архитектуры:
A.	Невозможность масштабирования
B.	Общая база данных на все сервисы
C.	Отдельное развертывание каждого сервиса
D.	Единый сервер для всех задач
ANSWER: C

123.	Использование облачной архитектуры в интеграции:
A.	Организация передачи структурированных данных внутри локальных хранилищ
B.	Предоставление вычислительных ресурсов и интерфейсов взаимодействия через удалённую платформу
C.	Выполнение процессов обмена информацией исключительно по традиционным протоколам
D.	Функционирование программных решений без подключения к сетевой инфраструктуре
ANSWER: B

124.	Протокол, используемый REST-сервисами:
A.	SMTP
B.	HTTP
C.	SSH
D.	FTP
ANSWER: B

125.	Особенность SOAP:
A.	Использование XML-сообщений
B.	Работа только через JSON
C.	Использование метода ping
D.	Отсутствие схемы данных
ANSWER: A

126.	Назначение Web API:
A.	Обмен данными между приложениями
B.	Создание графического интерфейса
C.	Выполнение системных команд
D.	Настройка прав пользователей
ANSWER: A

127.	Основное преимущество JSON:
A.	Легкость чтения и разбора
B.	Двоичное хранение данных
C.	Жесткая схема
D.	Ограничение вложенности
ANSWER: A

128.	Особенность XML:
A.	Невозможность валидации
B.	Теговая структура
C.	Отсутствие вложенности
D.	Только двоичные данные
ANSWER: B

129.	Признак gRPC:
A.	Использование HTTP/2
B.	Передача только CSV данных
C.	Работа исключительно по UDP
D.	Запрет сериализации
ANSWER: A

130.	Что относится к файловой интеграции:
A.	Вызовы REST-методов
B.	SOAP-запросы 
C.	Обмен CSV-файлами
D.	Работа через брокер сообщений
ANSWER: C

131.	Применение ETL-процесса в интеграции данных:
A.	Формирование элементов интерфейса в рамках пользовательских приложений
B.	Последовательное извлечение, структурирование и последующая загрузка информационных наборов
C.	Определение конфигурации взаимодействующих сетевых компонентов
D.	Подготовка и управление контейнеризованными программными средами
ANSWER: B

132.	Назначение middleware в интеграции:
A.	Посредник между системами при обмене данными
B.	Формирование структурированных файловых отчетов на основе данных
C.	Создание автоматизированных процедур обработки информации
D.	Разработка интерфейсных элементов для пользовательских приложений
ANSWER: A

133.	Основная функция Enterprise Service Bus:
A.	Хранение резервных копий
B.	Управление Docker-контейнерами
C.	Централизованная маршрутизация сообщений
D.	Создание облачной среды
ANSWER: C

134.	Особенность работы брокера сообщений (RabbitMQ, Kafka):
A.	Передача сообщений через очереди 
B.	Хранение данных в файловом виде
C.	Работа только по FTP
D.	Отсутствие масштабируемости
ANSWER: A

135.	Подключение приложения к реляционной базе данных требует:
A.	Разработка собственного протокола
B.	Использование драйвера или коннектора
C.	Создание отдельного хранилища логов
D.	Обязательное использование XML
ANSWER: B

136.	Преимущество использования коннектора БД:
A.	Повышение скорости обработки сетевых ресурсов при выполнении операций
B.	Упрощение взаимодействия приложения и базы данных
C.	Формирование дополнительных элементов визуального представления системы
D.	Оптимизация структуры интерфейсных компонентов в программной среде
ANSWER: B

137.	Особенность MongoDB в интеграции:
A.	Обязательная строгая схема таблиц
B.	Только реляционный подход 
C.	Документная модель хранения данных
D.	Запрет на вложенные структуры
ANSWER: C

138.	Основная характеристика Redis:
A.	Хранение данных в оперативной памяти
B.	Обработка больших бинарных файлов
C.	Только дисковое хранение
D.	Работа через REST API
ANSWER: A

139.	Назначение репликации данных:
A.	Создание копий данных для обеспечения устойчивой работы системы
B.	Формирование элементов визуального интерфейса внутри мобильных решений
C.	Подготовка структурированных аналитических отчетов на основе запросов
D.	Применение механизмов защиты для передачи информационных потоков
ANSWER: A

140.	Что обеспечивает синхронизация данных:
A.	Актуальность данных между несколькими системами
B.	Поддержание резервного копирования и хранения информационных журналов
C.	Подготовку и управление контейнеризованными программными средами
D.	Контроль и обработку сетевых пакетов при передаче информации
ANSWER: A

141.	Основная функция ORM:
A.	Преобразование объектов в данные БД
B.	Создание микросервисов
C.	Оптимизация JavaScript-кода
D.	Управление файловой системой
ANSWER: A

142.	Что определяет API при интеграции:
A.	Правила взаимодействия между системами
B.	Стиль пользовательского интерфейса
C.	Объем физической памяти
D.	Метод упаковки контейнеров
ANSWER: A

143.	Для аутентификации в API чаще используется:
A.	OAuth 2.0
B.	SFTP
C.	FTP
D.	USB-токен без сети
ANSWER: A

144.	Для авторизации в API часто применяют:
A.	JWT
B.	PNG-файлы
C.	SMTP-письма
D.	CSV-описание
ANSWER: A

145.	Назначение API Gateway:
A.	Централизованное управление API
B.	Хранение бинарных данных
C.	Генерация web-страниц
D.	Установка обновлений сервера
ANSWER: A

146.	Что обеспечивает версионирование API:
A.	Совместимость новых и старых версий
B.	Ускорение работы GPU
C.	Миграцию данных в облако
D.	Замену всех сервисов сразу
ANSWER: A

147.	Что обеспечивает документация API:
A.	Описание методов и правил использования
B.	Ускорение работы сети
C.	Шифрование данных
D.	Оптимизацию БД
ANSWER: A

148.	Особенность подключения внешнего REST-сервиса:
A.	Использование HTTP-запросов
B.	Создание бинарных пакетов
C.	Использование только UDP
D.	Применение HTML-шаблонов
ANSWER: A

149.	Особенность подключения SOAP-сервисов:
A.	Использование WSDL
B.	Работа строго по JSON
C.	Только асинхронные запросы
D.	Передача данных исключительно через FTP
ANSWER: A

150.	Использование RESTful-сервисов обеспечивает:
A.	Стандартизированный обмен через HTTP
B.	Хранение данных в бинарном виде
C.	Чисто файловую интеграцию
D.	Работу только внутри локальной сети
ANSWER: A

151.	Основная задача подключения платежных сервисов:
A.	Обеспечение приема онлайн-платежей
B.	Хранение логов операций
C.	Запуск ETL-процессов
D.	Кэширование API-запросов
ANSWER: A

152.	Пример платежного сервиса для интеграции:
A.	Stripe
B.	SSH
C.	SMTP
D.	WebSocket
ANSWER: A

153.	Цель интеграции Google Maps API:
A.	Получение картографических данных
B.	Хранение cookie-файлов
C.	Оптимизация графики
D.	Создание очередей сообщений
ANSWER: A

154.	Интеграция почтовых сервисов позволяет:
A.	Автоматически отправлять письма
B.	Улучшать дизайн интерфейса
C.	Ускорять работу процессора
D.	Создавать контейнеры
ANSWER: A

155.	SMTP используется для:
A.	Отправки электронных писем
B.	Оптимизации SQL
C.	Упаковки Docker-образов
D.	Сжатия файлов
ANSWER: A

156.	Интеграция ERP-систем обеспечивает:
A.	Автоматизацию бизнес-процессов
B.	Создание UI-макетов
C.	Сжатие трафика
D.	Поддержку HTML
ANSWER: A

157.	Пример ERP-системы:
A.	SAP
B.	React
C.	SMTP
D.	Redis
ANSWER: A

158.	Цель интеграции CRM-систем:
A.	Управление клиентскими данными
B.	Создание виртуальных машин
C.	Шифрование трафика
D.	Установка драйверов устройств
ANSWER: A

159.	Пример CRM-системы:
A.	Salesforce
B.	FTP
C.	WebSocket
D.	Kubernetes
ANSWER: A

160.	Интеграция систем документооборота позволяет:
A.	Автоматизировать работу с документами
B.	Масштабировать API
C.	Генерировать случайные числа
D.	Открывать сетевые порты
ANSWER: A

161.	HRM-системы используются для:
A.	Управления кадрами и персоналом
B.	Управления контейнерами
C.	Оптимизации API
D.	Обработки XML
ANSWER: A

162.	Пример HRM-системы:
A.	BambooHR
B.	SMTP
C.	Redis
D.	Docker
ANSWER: A

163.	В образовательных системах интеграция применяется для:
A.	Связи LMS с электронными журналами
B.	Создания аудиофайлов
C.	Оптимизации CSS
D.	Разработки игр
ANSWER: A

164.	Основная угроза интеграции:
A.	Утечка данных при обмене
B.	Плохой дизайн интерфейса
C.	Недостаток оперативной памяти
D.	Ошибки стилизации CSS
ANSWER: A

165.	Применение шифрования данных обеспечивает:
A.	Защиту информации при передаче
B.	Ускорение выполнения SQL
C.	Создание UI-форм
D.	Оптимизацию Docker
ANSWER: A

166.	Контроль доступа необходим для:
A.	Управления правами пользователей
B.	Рисования интерфейсов
C.	Архивирования логов
D.	Сжатия данных
ANSWER: A

167.	Мониторинг интеграции позволяет:
A.	Отслеживать ошибки и состояние сервисов
B.	Улучшать визуальный дизайн
C.	Менять структуру БД
D.	Ускорять работу браузера
ANSWER: A

168.	Соответствие GDPR относится к:
A.	Защите персональных данных
B.	Генерации графиков
C.	Изменению сетевых настроек
D.	UML-моделированию
ANSWER: A

169.	Docker используется для:
A.	Контейнеризации приложений
B.	Отправки HTTP-запросов
C.	Управления доменами
D.	Мониторинга API
ANSWER: A

170.	Kubernetes применяется для:
A.	Оркестрации контейнеров
B.	Сжатия изображений
C.	Управления почтовыми сервисами
D.	Настройки SQL-схем
ANSWER: A

171.	Интеграция DevOps позволяет:
A.	Автоматизировать процесс сборки и развертывания
B.	Рисовать диаграммы UML
C.	Создавать графические интерфейсы
D.	Настраивать шифрование данных
ANSWER: A

172.	CI/CD в DevOps означает:
A.	Непрерывная интеграция и непрерывное развертывание
B.	Контроль версий файлов
C.	Создание резервных копий
D.	Настройку пользовательского интерфейса
ANSWER: A

173.	Применение микросервисов обеспечивает:
A.	Независимое масштабирование и развертывание
B.	Общую базу для всех сервисов
C.	Запуск монолитного приложения
D.	Только локальную работу
ANSWER: A

174.	Облачные сервисы для интеграции включают:
A.	AWS, Azure, Google Cloud
B.	FTP и SMTP
C.	Redis и MongoDB
D.	Docker и Kubernetes
ANSWER: A

175.	Интеграция IoT-устройств позволяет:
A.	Собирать и обрабатывать данные с сенсоров
B.	Управлять Docker-контейнерами
C.	Создавать виртуальные машины
D.	Настраивать только локальные базы
ANSWER: A

176.	Подключение онлайн-платежей в интернет-магазин обеспечивает:
A.	Прием платежей через интернет
B.	Генерацию отчетов о продажах
C.	Создание UI-компонентов
D.	Хранение логов на сервере
ANSWER: A

177.	Интеграция CRM с сайтом компании позволяет:
A.	Автоматизировать работу с клиентами
B.	Настраивать серверные бэкапы
C.	Ускорять загрузку веб-страниц
D.	Создавать графику для сайта
ANSWER: A

178.	Синхронизация данных между двумя БД обеспечивает:
A.	Актуальность информации в обеих базах
B.	Создание резервной копии
C.	Оптимизацию SQL-запросов
D.	Шифрование данных
ANSWER: A

179.	Подключение чата или мессенджера к сайту позволяет:
A.	Обеспечить общение с клиентами в реальном времени
B.	Создавать отчеты о посещаемости
C.	Хранить данные в локальной папке
D.	Настраивать очереди сообщений
ANSWER: A

180.	Настройка системы аналитики позволяет:
A.	Отслеживать поведение пользователей
B.	Настраивать базы данных
C.	Контролировать доступ к файлам
D.	Создавать Docker-контейнеры
ANSWER: A

181.	Unit-тесты интеграции предназначены для:
A.	Проверки отдельных компонентов системы
B.	Шифрования данных
C.	Контроля доступа пользователей
D.	Мониторинга логов
ANSWER: A

182.	Integration-тесты проверяют:
A.	Взаимодействие нескольких модулей
B.	Внешние подключения к интернету
C.	UI и CSS
D.	Настройку облачных серверов
ANSWER: A

183.	System-тесты позволяют:
A.	Проверить работу всей системы целиком
B.	Настроить микросервисы
C.	Создать резервные копии
D.	Управлять API Gateway
ANSWER: A

184.	Логирование API используется для:
A.	Отслеживания вызовов и ошибок
B.	Создания Docker-образов
C.	Хранения файлов на сервере
D.	Настройки микросервисов
ANSWER: A

185.	Поддержка интеграционных решений после внедрения включает:
A.	Исправление ошибок и обновление модулей
B.	Генерацию PDF-отчетов
C.	Создание локальных папок
D.	Разработку UI
ANSWER: A

186.	Управление изменениями при интеграции обеспечивает:
A.	Контроль версий и конфигураций
B.	Оптимизацию SQL-запросов
C.	Архивацию данных
D.	Настройку CSS
ANSWER: A

187.	AI-технологии в интеграции помогают:
A.	Автоматизировать обработку данных
B.	Создавать новые серверы
C.	Управлять Docker
D.	Настраивать HTML-шаблоны
ANSWER: A

188.	Автоматизация в интеграции позволяет:
A.	Снизить ручной труд и ошибки
B.	Управлять графикой интерфейса
C.	Хранить данные только локально
D.	Настраивать очереди сообщений вручную
ANSWER: A

189.	Основная цель анализа интеграционных технологий:
A.	Выбор оптимальных решений для бизнеса
B.	Создание резервных копий
C.	Настройка локальной сети
D.	Архивирование данных
ANSWER: A

190.	Основная задача интеграции данных через файлы:
A.	Обмен информацией между системами без прямого соединения
B.	Контроль доступа к API
C.	Мониторинг серверов
D.	Создание микросервисов
ANSWER: A

191.	Форматы файлов для интеграции данных:
A.	CSV, Excel, XML
B.	JPG, PNG, GIF
C.	MP3, WAV
D.	HTML, CSS, JS
ANSWER: A

192.	Enterprise Service Bus (ESB) используется для:
A.	Централизованной маршрутизации сообщений
B.	Создания UI-компонентов
C.	Оптимизации локальной памяти
D.	Архивации логов
ANSWER: A

193.	Middleware помогает:
A.	Соединять приложения для обмена данными
B.	Сжимать медиафайлы
C.	Настраивать мониторинг
D.	Генерировать HTML-страницы
ANSWER: A

194.	Настройка ETL-процессов включает:
A.	Extract, Transform, Load
B.	Encode, Transfer, Log
C.	Extract, Test, Load
D.	Execute, Transform, Link
ANSWER: A

195.	Подключение реляционной БД требует:
A.	Драйверов и коннекторов
B.	Использования XML
C.	Настройки Docker-контейнера
D.	Контейнеризации всех сервисов
ANSWER: A

196.	Применение NoSQL баз данных в интеграции:
A.	MongoDB, Redis
B.	MySQL, PostgreSQL
C.	SOAP, REST
D.	Excel, CSV
ANSWER: A

197.	Репликация данных обеспечивает:
A.	Создание копий данных для надежности
B.	Автоматическое масштабирование
C.	Обновление Docker-контейнеров
D.	Настройку API Gateway
ANSWER: A

198.	Синхронизация данных нужна для:
A.	Поддержания актуальности информации в разных системах
B.	Создания резервных копий
C.	Настройки облачного хранилища
D.	Архивации логов
ANSWER: A

199.	ORM используется для:
A.	Преобразования объектов приложения в записи БД
B.	Настройки облачных сервисов
C.	Управления микросервисами
D.	Шифрования данных
ANSWER: A

200.	Разработка и использование API включает:
A.	Определение методов и контрактов
B.	Настройку мониторинга сервера
C.	Архивацию файлов
D.	Создание Docker-образов
ANSWER: A

201.	Настройка аутентификации API:
A.	OAuth 2.0
B.	SMTP
C.	FTP
D.	SSH
ANSWER: A

202.	Настройка авторизации API:
A.	JWT
B.	HTML
C.	CSV
D.	JSON
ANSWER: A

203.	API Gateway позволяет:
A.	Управлять всеми API централизованно
B.	Хранить бинарные файлы
C.	Генерировать отчеты
D.	Архивировать данные
ANSWER: A

204.	Версионирование API нужно для:
A.	Поддержки совместимости разных версий
B.	Создания новых баз данных
C.	Сжатия логов
D.	Настройки контейнеров
ANSWER: A

205.	Документирование API обеспечивает:
A.	Описание методов и правил использования
B.	Настройку очередей сообщений
C.	Хранение файлов
D.	Создание Docker-образов
ANSWER: A

206.	Подключение внешнего сервиса через API требует:
A.	Использование HTTP-запросов
B.	Архивацию данных
C.	Настройку CSS
D.	Генерацию логов
ANSWER: A

207.	Подключение SOAP-сервисов требует:
A.	Использование WSDL
B.	JSON-сообщений
C.	CSV-файлов
D.	HTML-шаблонов
ANSWER: A

208.	RESTful-сервисы позволяют:
A.	Стандартизованный обмен через HTTP
B.	Хранение данных только локально
C.	Создание резервных копий
D.	Шифрование файлов
ANSWER: A

209.	Подключение платежных сервисов через API обеспечивает:
A.	Онлайн-оплату клиентов
B.	Автоматическую генерацию отчетов
C.	Архивацию логов
D.	Создание микросервисов
ANSWER: A

210.	Подключение картографических сервисов позволяет:
A.	Использовать геоданные в приложениях
B.	Шифровать данные
C.	Настраивать Docker
D.	Хранить резервные копии
ANSWER: A

211.	Примеры картографических сервисов:
A.	Google Maps, OpenStreetMap
B.	FTP, SMTP
C.	Redis, MongoDB
D.	AWS, Azure
ANSWER: A

212.	Интеграция почтовых сервисов используется для:
A.	Автоматической отправки сообщений
B.	Хранения больших файлов
C.	Создания резервных копий
D.	Мониторинга API
ANSWER: A

213.	Подключение ERP-систем обеспечивает:
A.	Автоматизацию бизнес-процессов
B.	Настройку веб-сайта
C.	Сжатие данных
D.	Создание отчетов в Excel
ANSWER: A

214.	Примеры ERP-систем:
A.	SAP, 1С, Oracle
B.	Redis, MongoDB
C.	FTP, SMTP
D.	Docker, Kubernetes
ANSWER: A

215.	Подключение CRM-систем позволяет:
A.	Управлять клиентскими данными
B.	Хранить резервные копии
C.	Настраивать микросервисы
D.	Создавать контейнеры
ANSWER: A

216.	Примеры CRM-систем:
A.	Bitrix24, Salesforce
B.	OpenStreetMap, Google Maps
C.	Redis, MongoDB
D.	Docker, Kubernetes
ANSWER: A

217.	Интеграция систем документооборота позволяет:
A.	Автоматизировать обработку документов
B.	Настраивать очереди сообщений
C.	Создавать резервные копии
D.	Архивировать логи
ANSWER: A

218.	Подключение HRM-систем необходимо для:
A.	Управления кадрами и персоналом
B.	Настройки API Gateway
C.	Создания микросервисов
D.	Настройки ETL-процессов
ANSWER: A

219.	Примеры HRM-систем:
A.	BambooHR, SAP SuccessFactors
B.	Redis, MongoDB
C.	FTP, SMTP
D.	Google Analytics, Яндекс Метрика
ANSWER: A

220.	Примеры интеграции в образовательных системах:
A.	LMS с электронными журналами
B.	Настройка Docker
C.	Архивация логов
D.	Шифрование данных
ANSWER: A

221.	Основная угроза интеграции данных:
A.	Утечка или потеря информации
B.	Медленная работа интерфейса
C.	Ошибки CSS
D.	Недостаток памяти
ANSWER: A

222.	Применение шифрования данных необходимо для:
A.	Защиты информации при передаче
B.	Создания Docker-образов
C.	Настройки API Gateway
D.	Оптимизации SQL
ANSWER: A

223.	Контроль доступа позволяет:
A.	Управлять правами пользователей
B.	Настраивать резервное копирование
C.	Создавать контейнеры
D.	Архивировать логи
ANSWER: A

224.	Мониторинг интеграции обеспечивает:
A.	Отслеживание состояния сервисов и ошибок
B.	Оптимизацию CSS
C.	Генерацию случайных чисел
D.	Архивацию данных
ANSWER: A

225.	Соответствие GDPR необходимо для:
A.	Защиты персональных данных
B.	Настройки Docker
C.	Создания резервных копий
D.	Оптимизации SQL-запросов
ANSWER: A

226.	Использование контейнеров упрощает:
A.	Развертывание и управление приложениями
B.	Настройку пользовательского интерфейса
C.	Создание резервных копий
D.	Архивацию логов
ANSWER: A

227.	Docker позволяет:
A.	Контейнеризовать приложения
B.	Настраивать API Gateway
C.	Архивировать базы данных
D.	Создавать отчеты в Excel
ANSWER: A

228.	Kubernetes используется для:
A.	Оркестрации контейнеров
B.	Хранения файлов
C.	Мониторинга SMTP
D.	Настройки CSS
ANSWER: A

229.	Интеграция DevOps в CI/CD помогает:
A.	Автоматизировать сборку и развертывание
B.	Создавать резервные копии
C.	Настраивать локальную сеть
D.	Архивировать данные
ANSWER: A

230.	Микросервисы позволяют:
A.	Разделять систему на независимые сервисы
B.	Создавать резервные копии
C.	Шифровать данные
D.	Оптимизировать CSS
ANSWER: A

231.	Преимущество микросервисной архитектуры:
A.	Независимое масштабирование каждого сервиса
B.	Использование одной общей базы данных
C.	Обязательная установка облака
D.	Запуск всех сервисов на одном сервере
ANSWER: A

232.	Облачные сервисы применяются для:
A.	Хостинга и интеграции приложений
B.	Настройки локальной сети
C.	Архивации логов
D.	Создания CSS-шаблонов
ANSWER: A

233.	Примеры облачных платформ:
A.	AWS, Azure, Google Cloud
B.	Redis, MongoDB
C.	FTP, SMTP
D.	Bitrix24, Salesforce
ANSWER: A

234.	Интеграция IoT позволяет:
A.	Собирать данные с устройств и сенсоров
B.	Настраивать резервное копирование
C.	Создавать UI
D.	Архивировать файлы
ANSWER: A

235.	Онлайн-платежи в интернет-магазине обеспечивают:
A.	Прием оплаты от клиентов
B.	Архивацию логов
C.	Настройку контейнеров
D.	Создание отчетов
ANSWER: A

236.	Интеграция CRM с сайтом компании позволяет:
A.	Автоматизировать работу с клиентами
B.	Создавать резервные копии
C.	Настраивать микросервисы
D.	Генерировать Docker-образы
ANSWER: A

237.	Синхронизация данных между БД нужна для:
A.	Поддержания актуальной информации
B.	Настройки облачных сервисов
C.	Архивации логов
D.	Создания отчетов в Excel
ANSWER: A

238.	Подключение чата к сайту обеспечивает:
A.	Общение с пользователями в реальном времени
B.	Создание резервных копий
C.	Архивацию логов
D.	Настройку Docker
ANSWER: A

239.	Интеграция системы аналитики позволяет:
A.	Отслеживать поведение пользователей
B.	Создавать резервные копии
C.	Настраивать локальный сервер
D.	Архивировать данные
ANSWER: A

240.	Unit-тесты помогают:
A.	Проверять отдельные компоненты системы
B.	Автоматизировать сборку
C.	Настраивать облачные сервисы
D.	Архивировать логи
ANSWER: A

241.	Integration-тесты проверяют:
A.	Взаимодействие нескольких модулей
B.	Настройку UI
C.	Сжатие логов
D.	Архивацию файлов
ANSWER: A

242.	System-тесты проверяют:
A.	Работу всей системы целиком
B.	Настройку Docker
C.	Создание резервных копий
D.	Архивацию логов
ANSWER: A

243.	Поддержка интеграционных решений включает:
A.	Исправление ошибок и обновление модулей
B.	Настройку CSS
C.	Создание резервных копий
D.	Архивацию логов
ANSWER: A

244.	Управление изменениями при интеграции нужно для:
A.	Контроля версий и конфигураций
B.	Настройки резервного копирования
C.	Создания UI
D.	Архивации логов
ANSWER: A

245.	AI-технологии в интеграции помогают:
A.	Автоматизировать обработку данных
B.	Настраивать Docker
C.	Создавать резервные копии
D.	Архивировать файлы
ANSWER: A

246.	Автоматизация в интеграции позволяет:
A.	Снизить ручной труд и ошибки
B.	Настроить CSS
C.	Создать резервные копии
D.	Архивировать логи
ANSWER: A

247.	Low-code/no-code платформы применяются для:
A.	Быстрой интеграции без программирования
B.	Архивации логов
C.	Создания резервных копий
D.	Настройки Docker
ANSWER: A

248.	Основная цель анализа интеграционных технологий:
A.	Выбрать оптимальные решения для бизнеса
B.	Настроить резервное копирование
C.	Создать Docker-образ
D.	Архивировать логи
ANSWER: A

249.	Вертикальная интеграция характеризуется:
A.	Соединением систем разных уровней внутри компании
B.	Связью одинаковых систем между собой
C.	Подключением только облачных сервисов
D.	Использованием исключительно файлов
ANSWER: A

250.	Горизонтальная интеграция обеспечивает:
A.	Обмен данными между системами одного уровня
B.	Связь с внешними API
C.	Шифрование информации
D.	Мониторинг серверов
ANSWER: A

251.	Точка-точка интеграция подразумевает:
A.	Прямое соединение двух систем
B.	Использование шины данных
C.	Обязательное облачное подключение
D.	Контейнеризацию сервисов
ANSWER: A

252.	Основная цель интеграции в цифровой трансформации:
A.	Автоматизация и оптимизация бизнес-процессов
B.	Настройка резервного копирования
C.	Создание CSS и UI
D.	Архивация логов
ANSWER: A

253.	Компоненты информационной системы включают:
A.	Аппаратное обеспечение, ПО, данные, люди, процессы
B.	Только серверы и базы данных
C.	Только микросервисы
D.	Только облачные сервисы
ANSWER: A

254.	Клиент-серверная архитектура подразумевает:
A.	Разделение ролей на клиентскую и серверную части
B.	Запуск всех процессов на одном сервере
C.	Использование только локальных файлов
D.	Прямое соединение двух клиентов
ANSWER: A

255.	Многоуровневая архитектура позволяет:
A.	Применять методы сжатия информации
B.	Упаковывать и хранить системные журналы
C.	Конфигурировать исключительно облачные решения
D.	Разделять приложения на логические уровни
ANSWER: D

256.	SOA (сервис-ориентированная архитектура) подразумевает:
A.	Процесс архивации корпоративных данных
B.	Создание локальных резервных копий 
C.	Использование сервисов для взаимодействия систем
D.	Настройка стилей CSS
ANSWER: C

257.	Основное преимущество микросервисной архитектуры:
A.	Использование одной базы данных 
B.	Независимость и масштабируемость сервисов
C.	Обязательная работа на облаке
D.	Подключение только файлов
ANSWER: B

258.	HTTP, REST и SOAP применяются для:
A.	Обмена данными между системами
B.	Архивации логов
C.	Создания резервных копий
D.	Настройки контейнеров
ANSWER: A

259.	Web API используется для:
A.	Процесс упаковки и сохранения данных
B.	Настройка среды контейнеризации Docker
C.	Взаимодействия программ через интернет
D.	Осуществление компрессии для файлов
ANSWER: C

260.	JSON и XML применяются для:
A.	Структурированной передачи данных
B.	Настройки резервного копирования
C.	Создания UI интерфейса
D.	Мониторинга серверов
ANSWER: A

261.	Протокол gRPC обеспечивает:
A.	Процесс упаковки системных логов
B.	Создание копий для восстановления данных
C.	Настройка стилей веб-страниц (CSS)
D.	Быстрая связь между разными сервисами
ANSWER: D

262.	Интеграция через файлы используется для:
A.	Создание копий для восстановления систем
B.	Обмен информацией при отсутствии связи
C.	Настройка среды для контейнеров
D.	Осуществление защиты данных шифрованием
ANSWER: B

263.	Настройка репликации данных обеспечивает:
A.	Архивацию логов
B.	Настройку стилей CSS веб-страниц
C.	Создание резервных копий вручную
D.	Создание копий для отказоустойчивости
ANSWER: D

264.	ORM помогает:
A.	Архивировать данные
B.	Настраивать среды для контейнеров
C.	Связывать объекты программы с БД
D.	Создавать копии для восстановления систем
ANSWER: C

265.	Аутентификация API может использовать:
A.	OAuth 2.0
B.	FTP
C.	SMTP
D.	CSV
ANSWER: A

266.	Авторизация API обычно реализуется через:
A.	PNG
B.	HTML 
C.	JWT
D.	CSV
ANSWER: C

267.	API Gateway нужен для:
A.	Создания копий для восстановления систем
B.	Архивации логов 
C.	Централизованного управления API
D.	Настройки CSS веб-страниц
ANSWER: C

268.	Документирование API необходимо для:
A.	Архивации логов
B.	Настройки системы резервного копирования
C.	Создания файлов образов Docker
D.	Описания методов и правил использования
ANSWER: D

269.	SOAP-сервисы требуют:
A.	JSON для передачи информации 
B.	WSDL для описания интерфейсов
C.	CSV для экспорта
D.	HTML для документации
ANSWER: B

270.	RESTful-сервисы позволяют:
A.	Обмениваться данными через HTTP
B.	Архивировать файлы
C.	Создавать копии для восстановления систем
D.	Настраивать стилей CSS веб-страниц
ANSWER: A

271.	Подключение онлайн-платежей через API обеспечивает:
A.	Проведение аудита финансовой системы
B.	Шифрование всех локальных баз данных
C.	Настройка стилей веб-страниц (CSS)
D.	Прием платежей от клиентов компании
ANSWER: D

272.	Интеграция картографических сервисов позволяет:
A.	Архивировать лог-файлы 
B.	Использовать геоданные и карты в приложениях
C.	Настраивать системы резервного копирования
D.	Создавать CSS-шаблоны
ANSWER: B

273.	Подключение почтовых сервисов обеспечивает:
A.	Создание копий для восстановления систем
B.	Автоматическую отправку писем
C.	Процесс упаковки системных логов
D.	Настройку стилей веб-страниц (CSS)
ANSWER: B

274.	Интеграция ERP-систем позволяет:
A.	Проводить автоматическое резервное копирование
B.	Настраивать интерфейс пользователя (UX/UI)
C.	Осуществлять только финансовый аудит 
D.	Автоматизировать ключевые бизнес-процессы
ANSWER: D

275.	Подключение CRM-систем обеспечивает:
A.	Организацию структуры каталогов файлов 
B.	Управление клиентской базой
C.	Регулирование прав доступа пользователей к сети
D.	Проведение автоматизированного тестирования кода
ANSWER: B

276.	Интеграция систем документооборота нужна для:
A.	Автоматизации работы с документами
B.	Проведения технического анализа кода
C.	Создания шаблонов стилей (CSS)
D.	Настройки контейнеров Docker и Kubernetes
ANSWER: A

277.	HRM-системы применяются для:
A.	Проведение бухгалтерского и налогового учета
B.	Управления персоналом и кадрами
C.	Мониторинг облачной и сетевой инфраструктуры
D.	Проведения комплексного тестирования кода
ANSWER: B

278.	Интеграция образовательных систем позволяет:
A.	Связывать LMS и электронные журналы
B.	Организацию структуры каталогов файлов
C.	Регулировать права доступа пользователей к сети
D.	Проведить комплексное тестирование кода
ANSWER: A

279.	Основная угроза при интеграции:
A.	Проведение автоматизированного тестирования кода
B.	Организацию структуры каталогов файлов
C.	Утечка или потеря данных
D.	Регулирование прав доступа пользователей к сети
ANSWER: C

280.	Шифрование данных обеспечивает:
A.	Проведение автоматизированного тестирования кода
B.	Организацию структуры каталогов файлов
C.	Регулирование прав доступа пользователей к сети
D.	Безопасность при обмене информацией
ANSWER: D

281.	Контроль доступа позволяет:
A.	Управлять правами пользователей
B.	Настраивать Docker
C.	Создавать резервные копии
D.	Архивировать данные
ANSWER: A

282.	Мониторинг интеграции обеспечивает:
A.	Автоматическое создание резервных копий данных
B.	Шифрование всего сетевого трафика 
C.	Отслеживание состояния сервисов и ошибок
D.	Управление внешним видом веб-страниц
ANSWER: C

283.	Соответствие GDPR необходимо для
A.	Мониторинга сетевой и облачной инфраструктуры 
B.	Защиты персональных данных
C.	Контроля версий программного кода в Git
D.	Обеспечения быстрой коммуникации между сервисами
ANSWER: B

284.	Контейнеризация упрощает:
A.	Проведение комплексного тестирования кода
B.	Организацию структуры каталогов файлов 
C.	Развертывание и управление приложениями
D.	Регулирование прав доступа пользователей к сети
ANSWER: C

285.	Kubernetes применяется для
A.	Оркестрации контейнеров
B.	Создания резервных копий
C.	Хранение файлов в облаке
D.	Мониторинг состояния микросервисов
ANSWER: A

286.	Основная цель DevOps интеграции:
A.	Автоматизация начисления, учета и выплаты заработной платы
B.	Автоматизация фиксации, упаковки и переноса файлов в архив 
C.	Автоматизация сборки, тестирования и развертывания
D.	Автоматизация планирования, распределения и контроля бюджета
ANSWER: C

287.	Непрерывная интеграция (CI) позволяет:
A.	Постоянное планирование, контроль и анализ рыночной стратегии
B.	Постоянное начисление, учет и выплата заработной платы
C.	Постоянное объединение, проверка и сведение нового кода
D.	Постоянное финансирование, поддержка и управление внешним веб-сайтом
ANSWER: C

288.	Непрерывное развертывание (CD) обеспечивает:
A.	Постоянное начисление, учет и выплату заработной платы
B.	Постоянный контроль, анализ и утверждение маркетинговых планов
C.	Постоянное финансирование, поддержку и управление внешним веб-сайтом
D.	Постоянную доставку, передачу и запуск нового кода в среду
ANSWER: D

289.	Микросервисы взаимодействуют через:
A.	CSS и HTML 
B.	API и сообщения
C.	Архивацию логов
D.	Резервные копии
ANSWER: B

290.	Облачные сервисы помогают:
A.	Хранить, масштабировать и интегрировать приложения
B.	Начислять, учитывать и выплачивать заработную плату
C.	Контролировать, анализировать и утверждать маркетинговые планы
D.	Финансировать, поддерживать и управлять внешним веб-сайтом
ANSWER: A

291.	Основная цель интеграции новых приложений в существующую ИС:
A.	Уменьшение количества серверов 
B.	Обеспечение совместимости и обмена данными 
C.	Удаление устаревших модулей
D.	Изоляция сервисов
ANSWER: B

292.	Особенность интеграции через шину данных (ESB):
A.	Требует ручного ввода данных 
B.	Централизует маршрутизацию и трансформацию сообщений
C.	Работает только с файлами CSV 
D.	Использует исключительно протокол FTP
ANSWER: B

293.	Преимущество использования микросервисной архитектуры при интеграции:
A.	Невозможность обновления компонентов
B.	Масштабирование отдельных сервисов
C.	Единый монолитный код
D.	Зависимость от одного сервера
ANSWER: B

294.	Особенность интеграции через очереди сообщений (Message Broker):
A.	Работа только в ручном режиме 
B.	Синхронное выполнение всех процессов 
C.	Асинхронный обмен данными между сервисами 
D.	Обязательное наличие одной базы данных
ANSWER: C

295.	Настройка системы аналитики позволяет:
A.	Отслеживать поведение пользователей
B.	Создавать резервные копии
C.	Архивировать данные
D.	Настраивать CSS
ANSWER: A

296.	Результат успешной интеграции сервисов:
A.	Снижение согласованности данных 
B.	Увеличение времени отклика 
C.	Бесшовное взаимодействие систем
D.	Отсутствие логирования
ANSWER: C

297.	Преимущество REST при интеграции систем:
A.	Работа только в локальных сетях 
B.	Наличие сложных бинарных протоколов
C.	Использование стандартных HTTP-методов
D.	Отсутствие кэширования
ANSWER: C

298.	Особенность интеграции через микросервисы:
A.	Все компоненты запускаются как один модуль
B.	Каждый сервис выполняет ограниченную функцию
C.	Не допускается обновление частей системы
D.	Используется один общий процесс
ANSWER: B

299.	Назначение протокола SOAP при интеграции приложений:
A.	Передача сообщений в формате XML
B.	Хранение файлов в облаке
C.	Мониторинг состояния микросервисов
D.	Выполнение параллельных вычислений
ANSWER: A

300.	Признак слабой связности систем при интеграции:
A.	Компоненты жестко зависят друг от друга
B.	Компоненты могут изменяться независимо
C.	Обязательное использование одной базы данных
D.	Наличие единого монолитного ядра
ANSWER: B

301.	Преимущество синхронного взаимодействия сервисов:
A.	Гарантия мгновенного ответа от сервиса
B.	Возможность сохранения состояния
C.	Минимальное время отклика независимо от нагрузки
D.	Передача больших данных без задержек
ANSWER: A

302.	Особенность интеграции через файловый обмен (CSV, JSON):
A.	Требует ручного запуска каждого процесса
B.	Работает без прямого соединения между системами
C.	Передает данные только через HTTP
D.	Не допускает использование облачных хранилищ
ANSWER: B

303.	SOAP отличается от REST тем, что:
A.	Использует строгий протокол и XML
B.	Передает данные только через JSON
C.	Применяется только для баз данных
D.	Требует контейнеризацию
ANSWER: A


